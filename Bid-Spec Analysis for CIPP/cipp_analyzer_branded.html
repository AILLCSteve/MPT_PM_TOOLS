<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIPP Bid-Spec Analyzer - MPT Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            padding: 0;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/shared/assets/images/bg3.jpg');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            filter: brightness(0.75);
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(91, 127, 204, 0.4) 0%, rgba(30, 58, 138, 0.5) 100%);
            z-index: -1;
        }

        .container {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(2.5px);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            max-width: 1000px;
            width: calc(100% - 40px);
            min-height: 600px;
            margin: 20px auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #ffffff;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #ffffff;
            font-size: 1.1em;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid rgba(224, 224, 224, 0.5);
            border-radius: 8px;
            background: transparent;
        }

        .section h3 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #ffffff;
            font-weight: 500;
        }

        input[type="text"], input[type="password"], input[type="file"], input[type="number"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, input[type="password"]:focus, input[type="number"]:focus, textarea:focus {
            outline: none;
            border-color: #5B7FCC;
        }

        .file-upload {
            border: 2px dashed rgba(221, 221, 221, 0.7);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
        }

        .file-upload:hover {
            border-color: #5B7FCC;
            background: rgba(248, 249, 255, 0.95);
        }

        .btn {
            background: linear-gradient(45deg, #5B7FCC, #1E3A8A);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-test {
            background: #28a745;
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #5B7FCC, #1E3A8A);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #ffffff;
        }

        .log-container {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            display: none;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
            white-space: pre-wrap;
        }

        .log-info { color: #17a2b8; }
        .log-success { color: #28a745; }
        .log-warning { color: #ffc107; }
        .log-error { color: #dc3545; }
        .log-debug { color: #6f42c1; }
        .log-api { color: #fd7e14; background: #fff3cd; padding: 5px; border-radius: 3px; }
        .log-request { color: #0056b3; background: #cce5ff; padding: 5px; border-radius: 3px; }
        .log-response { color: #155724; background: #d4edda; padding: 5px; border-radius: 3px; }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-ready { background: #28a745; }
        .status-processing { background: #ffc107; }
        .status-error { background: #dc3545; }

        .results-section {
            display: none;
            margin-top: 20px;
        }

        .question-sections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .question-section {
            border: 1px solid rgba(221, 221, 221, 0.6);
            border-radius: 6px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            cursor: pointer;
            transition: all 0.3s;
        }

        .question-section:hover {
            border-color: #5B7FCC;
            background: rgba(255, 255, 255, 0.95);
        }

        .question-section.enabled {
            border-color: #28a745;
            background: rgba(248, 255, 248, 0.9);
        }

        .question-section.disabled {
            border-color: #dc3545;
            background: rgba(255, 248, 248, 0.9);
            opacity: 0.7;
        }

        .section-header {
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-count {
            font-size: 12px;
            color: #666;
            background: #f0f0f0;
            padding: 2px 8px;
            border-radius: 12px;
        }

        .service-status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
            text-align: center;
        }

        .service-running {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .service-stopped {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        /* Export menu button hover */
        #exportMenu button:hover {
            background: #f0f0f0 !important;
            font-weight: 500;
        }

        #exportMenu button:active {
            background: #e0e0e0 !important;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            font-weight: bold;
        }

        .close-btn:hover {
            color: #666;
        }

        /* MPT Navbar */
        .mpt-navbar {
            background: linear-gradient(135deg, #1E3A8A, #5B7FCC);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
            margin-bottom: 0;
        }

        .mpt-navbar .logo-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .mpt-navbar img {
            height: 40px;
            width: auto;
        }

        .mpt-navbar .app-title {
            color: white;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .mpt-navbar .home-link {
            color: white;
            text-decoration: none;
            padding: 8px 20px;
            border: 2px solid white;
            border-radius: 5px;
            transition: all 0.3s;
            font-weight: 500;
        }

        .mpt-navbar .home-link:hover {
            background-color: white;
            color: #1E3A8A;
        }

        /* Mobile responsive for navbar and background */
        @media (max-width: 768px) {
            body::before {
                background-attachment: scroll;
                background-size: cover;
                background-position: center center;
            }

            .mpt-navbar {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }

            .container {
                padding: 20px;
                width: calc(100% - 20px);
                margin: 10px auto;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .header p {
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            body::before {
                background-size: auto 100%;
                background-position: center center;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- MPT Navigation Bar -->
    <nav class="mpt-navbar">
        <div class="logo-container">
            <img src="/shared/assets/images/logo.png" alt="Municipal Pipe Tool">
            <span class="app-title">CIPP Bid-Spec Analyzer</span>
        </div>
        <a href="/" class="home-link">‚Üê Home</a>
    </nav>

    <div class="container">
        <div class="header">
            <h1>üèóÔ∏è CIPP Bid-Spec Analyzer</h1>
            <p>Professional bid specification analysis powered by AI</p>
        </div>

        <!-- Document Service Status -->
        <div id="serviceStatus" class="service-status service-stopped">
            <span id="serviceStatusText">üìÑ Checking document extraction service...</span>
        </div>

        <!-- API Configuration Section -->
        <div class="section">
            <h3><span class="status-indicator" id="apiStatus"></span>API Connection Status</h3>
            <div class="form-group">
                <p id="apiStatusText">Loading API configuration...</p>
            </div>
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn btn-test" id="testConnectionBtn" onclick="testApiConnection()">üîó Test Connection</button>
                <span id="testStatusDisplay" style="font-weight: 500; padding: 8px 16px; border-radius: 6px; display: none;"></span>
            </div>
        </div>

        <!-- File Upload Section -->
        <div class="section">
            <h3>üìÑ Document Upload</h3>
            <div class="file-upload" id="fileUpload" onclick="document.getElementById('fileInput').click()">
                <input type="file" id="fileInput" style="display: none;" accept=".pdf,.txt,.docx,.rtf" onchange="handleFileSelect(event)">
                <p><strong>Click to select file</strong> or drag and drop</p>
                <p>Supported formats: PDF, TXT, DOCX, RTF</p>
            </div>
            <div id="fileInfo" style="margin-top: 10px; display: none;">
                <p><strong>Selected file:</strong> <span id="fileName"></span></p>
                <p><strong>Size:</strong> <span id="fileSize"></span></p>
            </div>
            <button class="btn btn-test" onclick="loadTestDocument()" style="margin-top: 10px;">üìã Load Test Document</button>
        </div>

        <!-- Question Management Section -->
        <div class="section">
            <h3>‚ùì Question Configuration</h3>
            <div class="form-group">
                <label>Question Sections (Click to enable/disable):</label>
                <div id="questionSections" class="question-sections"></div>
            </div>
            <div class="form-group">
                <label>Active Questions: <span id="activeQuestionCount">0</span> questions selected</label>
            </div>
            <button class="btn btn-secondary" onclick="showQuestionManager()">üìù Manage Questions</button>
            <button class="btn btn-secondary" onclick="addQuestionSection()">‚ûï Add Custom Section</button>
            <button class="btn btn-secondary" onclick="exportQuestions()">üì§ Export Questions</button>
            <button class="btn btn-secondary" onclick="showSettings()">‚öôÔ∏è Settings</button>
        </div>

        <!-- Analysis Controls -->
        <div class="section">
            <h3>üéØ Analysis Configuration</h3>
            <div class="form-group">
                <label for="chunkSize">Characters per Analysis Chunk:</label>
                <input type="number" id="chunkSize" value="1500" min="500" max="2000">
                <small>Recommended: 1500 characters per chunk to stay within token limits (lowered due to GPT-4 constraints)</small>
            </div>
            <button class="btn" id="analyzeBtn" onclick="startAnalysis()" disabled>üöÄ Start Analysis</button>
            <button class="btn btn-danger" id="stopBtn" onclick="stopAnalysis()" disabled>‚èπÔ∏è Stop Analysis</button>
            <button class="btn btn-secondary" onclick="clearResults()">üóëÔ∏è Clear Results</button>
            <div class="btn-group" style="display: inline-block; position: relative;">
                <button class="btn btn-secondary" onclick="showExportMenu()" id="exportBtn" disabled>üìä Export Results ‚ñº</button>
                <div id="exportMenu" style="display: none; position: absolute; background: white; border: 2px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; min-width: 200px; top: 100%; left: 0; margin-top: 5px;">
                    <button onclick="exportResults('csv')" style="width: 100%; padding: 12px; border: none; background: white; text-align: left; cursor: pointer; border-bottom: 1px solid #eee;">üìÑ CSV (Excel)</button>
                    <button onclick="exportResults('markdown')" style="width: 100%; padding: 12px; border: none; background: white; text-align: left; cursor: pointer; border-bottom: 1px solid #eee;">üìù Markdown Table</button>
                    <button onclick="exportResults('html')" style="width: 100%; padding: 12px; border: none; background: white; text-align: left; cursor: pointer; border-bottom: 1px solid #eee;">üåê HTML Report</button>
                    <button onclick="exportResults('json')" style="width: 100%; padding: 12px; border: none; background: white; text-align: left; cursor: pointer;">üìã JSON Data</button>
                </div>
            </div>
        </div>

        <!-- Progress Section -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Ready</div>
        </div>

        <!-- Log Section -->
        <div class="log-container" id="logContainer">
            <div id="logContent"></div>
        </div>

        <!-- Live Results Section -->
        <div class="results-section" id="resultsSection" style="display: none;">
            <h3>üìã Analysis Results (Live Updates)</h3>
            <div id="liveResultsContainer">
                <div id="liveResultsTable"></div>
                <div id="resultsContent"></div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <button class="close-btn" onclick="hideSettings()">&times;</button>
            <h2>‚öôÔ∏è Application Settings</h2>
            <div class="form-group">
                <p style="padding: 15px; background: #e7f3ff; border-left: 4px solid #2196F3; border-radius: 4px;">
                    <strong>‚ÑπÔ∏è API Key Configuration</strong><br>
                    The OpenAI API key is configured via environment variables on the server.
                    Contact your system administrator to update the API key.
                </p>
            </div>
            <div class="form-group">
                <label for="gptModel">GPT Model:</label>
                <select id="gptModel">
                    <option value="gpt-4o">GPT-4o (Recommended - 128K context)</option>
                    <option value="gpt-4-turbo">GPT-4 Turbo (128K context)</option>
                    <option value="gpt-4">GPT-4 (8K context - may fail on large docs)</option>
                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo (16K context)</option>
                </select>
            </div>
            <button class="btn" onclick="saveSettings()">üíæ Save Settings</button>
            <button class="btn btn-secondary" onclick="hideSettings()">‚ùå Close</button>
        </div>
    </div>

    <!-- Question Manager Modal -->
    <div id="questionManagerModal" class="modal">
        <div class="modal-content" style="max-width: 95%; max-height: 90%;">
            <button class="close-btn" onclick="hideQuestionManager()">&times;</button>
            <h2>üìù Question Manager</h2>

            <div style="margin-bottom: 20px;">
                <label>Select Section to Edit:</label>
                <select id="sectionSelect" onchange="loadSectionForEdit()" style="width: 100%; padding: 8px; margin: 10px 0;">
                    <option value="">-- Select a section --</option>
                </select>
                <button class="btn btn-secondary" onclick="addNewSectionInManager()">‚ûï Add New Section</button>
                <button class="btn btn-danger" onclick="deleteCurrentSection()">üóëÔ∏è Delete Section</button>
            </div>

            <div id="sectionEditor" style="display: none;">
                <h3 id="currentSectionName"></h3>
                <div style="margin-bottom: 15px;">
                    <label>
                        <input type="checkbox" id="sectionEnabled" onchange="toggleSectionEnabled()">
                        Section Enabled
                    </label>
                </div>

                <div style="margin-bottom: 15px;">
                    <label>Section Name:</label>
                    <input type="text" id="sectionNameInput" onchange="updateSectionName()" style="width: 100%; padding: 8px;">
                </div>

                <div style="margin-bottom: 15px;">
                    <label>Questions in this section:</label>
                    <div id="questionsList" style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 6px; background: #f9f9f9;"></div>
                    <button class="btn btn-secondary" onclick="addNewQuestion()" style="margin-top: 10px;">‚ûï Add Question</button>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="btn" onclick="saveQuestions()">üíæ Save All Changes</button>
                <button class="btn btn-secondary" onclick="hideQuestionManager()">‚ùå Close</button>
                <button class="btn btn-secondary" onclick="exportQuestions()">üì§ Export Questions</button>
                <input type="file" id="importQuestionsFile" style="display: none;" accept=".json" onchange="importQuestions(event)">
                <button class="btn btn-secondary" onclick="document.getElementById('importQuestionsFile').click()">üì• Import Questions</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced Logger with comprehensive API debugging
        class Logger {
            static log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logContainer = document.getElementById('logContent');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;

                if (typeof message === 'object') {
                    entry.innerHTML = `[${timestamp}] <pre>${JSON.stringify(message, null, 2)}</pre>`;
                } else {
                    entry.textContent = `[${timestamp}] ${message}`;
                }

                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;

                document.getElementById('logContainer').style.display = 'block';
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            static info(message) { this.log(message, 'info'); }
            static success(message) { this.log(message, 'success'); }
            static warning(message) { this.log(message, 'warning'); }
            static error(message) { this.log(message, 'error'); }
            static debug(message) { this.log(message, 'debug'); }
            static api(message) { this.log(message, 'api'); }
            static request(message) { this.log(message, 'request'); }
            static response(message) { this.log(message, 'response'); }
        }

        // Progress tracking utility
        class ProgressTracker {
            static show() {
                document.getElementById('progressContainer').style.display = 'block';
            }

            static hide() {
                document.getElementById('progressContainer').style.display = 'none';
            }

            static update(percentage, text) {
                document.getElementById('progressFill').style.width = `${percentage}%`;
                document.getElementById('progressText').textContent = text;
            }
        }

        // Settings Manager
        class SettingsManager {
            constructor() {
                this.SETTINGS_VERSION = 2; // Increment when breaking changes made
                this.defaultSettings = {
                    version: this.SETTINGS_VERSION,
                    apiKey: '', // User must provide their own OpenAI API key
                    gptModel: 'gpt-4o', // GPT-4o with 128K context window
                    defaultChunkSize: 1500, // Reduced from 3000 to prevent token limit issues
                    analysisTimeout: 60,
                    autoRetry: true,
                    rateLimitDelay: 2000,
                    maxTokensPerRequest: 3000 // Reduced from 6000
                };
                this.settings = { ...this.defaultSettings };
                this.loadSettings();
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('cipp_analyzer_settings');
                    if (saved) {
                        const parsed = JSON.parse(saved);

                        // Check if settings need migration
                        if (!parsed.version || parsed.version < this.SETTINGS_VERSION) {
                            Logger.warning(`‚ö†Ô∏è Migrating settings from v${parsed.version || 1} to v${this.SETTINGS_VERSION}`);

                            // FORCE UPGRADE: Critical settings that must be updated
                            if (parsed.gptModel === 'gpt-4') {
                                Logger.warning('‚¨ÜÔ∏è Upgrading model: gpt-4 ‚Üí gpt-4o (128K context)');
                                parsed.gptModel = 'gpt-4o';
                            }

                            // Reduce excessive max_tokens
                            if (!parsed.maxTokensPerRequest || parsed.maxTokensPerRequest > 4000) {
                                Logger.warning(`‚¨áÔ∏è Reducing max_tokens: ${parsed.maxTokensPerRequest || 6000} ‚Üí 3000`);
                                parsed.maxTokensPerRequest = 3000;
                            }

                            // Mark as migrated
                            parsed.version = this.SETTINGS_VERSION;

                            // Save migrated settings
                            this.settings = { ...this.defaultSettings, ...parsed };
                            this.saveSettings();

                            Logger.success('‚úÖ Settings migrated successfully');
                        } else {
                            // Normal load
                            this.settings = { ...this.defaultSettings, ...parsed };
                        }
                    }
                } catch (error) {
                    Logger.warning('Could not load saved settings, using defaults');
                    this.settings = { ...this.defaultSettings };
                }
            }

            saveSettings() {
                try {
                    localStorage.setItem('cipp_analyzer_settings', JSON.stringify(this.settings));
                    Logger.success('Settings saved successfully');
                } catch (error) {
                    Logger.error('Failed to save settings: ' + error.message);
                }
            }

            get(key) {
                return this.settings[key];
            }

            set(key, value) {
                this.settings[key] = value;
                this.saveSettings();
            }
        }

        // Enhanced OpenAI API Client with comprehensive debugging
        class OpenAIClient {
            constructor(apiKey) {
                this.apiKey = apiKey;
                this.baseUrl = 'https://api.openai.com/v1';
                this.requestCount = 0;
            }

            // Estimate tokens (rough approximation: 1 token ‚âà 4 characters for English)
            estimateTokens(text) {
                if (!text) return 0;
                // More accurate estimation accounting for spaces and punctuation
                const words = text.split(/\s+/).length;
                const chars = text.length;
                // Average: 1 token per 0.75 words or 4 chars, whichever is higher
                return Math.ceil(Math.max(words / 0.75, chars / 4));
            }

            // Get model context limits
            getModelContextLimit(model) {
                const limits = {
                    'gpt-4o': 128000,
                    'gpt-4-turbo': 128000,
                    'gpt-4': 8192,
                    'gpt-3.5-turbo': 16384
                };
                return limits[model] || 8192;
            }

            async testConnection() {
                Logger.api("üîç Testing OpenAI API connection...");
                Logger.debug("API Key (masked): " + this.apiKey.substring(0, 10) + "..." + this.apiKey.substring(this.apiKey.length - 4));

                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    Logger.error("‚ùå Connection test timed out after 10 seconds");
                }, 10000);

                try {
                    Logger.request("üì§ Sending GET request to /models endpoint");

                    const response = await fetch(`${this.baseUrl}/models`, {
                        signal: controller.signal,
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    clearTimeout(timeoutId);
                    Logger.response(`üì• Received response: ${response.status} ${response.statusText}`);

                    if (response.ok) {
                        const data = await response.json();
                        Logger.success("‚úÖ OpenAI API connection successful");
                        Logger.debug(`Available models: ${data.data.length}`);
                        return true;
                    } else {
                        const errorText = await response.text();
                        Logger.error(`‚ùå API connection failed: ${response.status} - ${errorText}`);
                        return false;
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    if (error.name === 'AbortError') {
                        Logger.error(`‚è∞ API connection timed out after 10 seconds`);
                    } else {
                        Logger.error(`üí• API connection error: ${error.message}`);
                        Logger.debug(`Error details: ${error.stack}`);
                    }
                    return false;
                }
            }

            async analyzeSection(text, questions, sectionName, chunkNumber = 1, totalChunks = 1) {
                const requestId = ++this.requestCount;
                Logger.api(`üöÄ Starting analysis request #${requestId} for section "${sectionName}" chunk ${chunkNumber}/${totalChunks}`);

                const controller = new AbortController();
                const timeoutMs = (app.settingsManager.get('analysisTimeout') || 60) * 1000;
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    Logger.error(`‚è∞ Request #${requestId} timed out after ${timeoutMs/1000} seconds`);
                }, timeoutMs);

                try {
                    const prompt = this.buildSectionPrompt(text, questions, sectionName, chunkNumber, totalChunks);
                    const model = app.settingsManager.get('gptModel');

                    Logger.debug(`Request #${requestId} details:`);
                    Logger.debug(`- Section: ${sectionName}`);
                    Logger.debug(`- Model: ${model}`);
                    Logger.debug(`- Text length: ${text.length} characters`);
                    Logger.debug(`- Questions: ${questions.length}`);

                    const requestBody = {
                        model: model,
                        messages: [
                            {
                                role: 'system',
                                content: 'You are an expert construction specification analyst with deep expertise in CIPP (Cured-in-Place Pipe) sewer rehabilitation projects. You excel at reading and analyzing technical documents to extract specific information. You MUST respond with valid JSON only.'
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 4000,
                        temperature: 0.2
                    };

                    Logger.request(`üì§ Sending request #${requestId} to OpenAI API`);

                    const startTime = Date.now();
                    const response = await fetch(`${this.baseUrl}/chat/completions`, {
                        method: 'POST',
                        signal: controller.signal,
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    const requestTime = Date.now() - startTime;
                    Logger.response(`üì• Request #${requestId} response received in ${requestTime}ms: ${response.status} ${response.statusText}`);

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errorText = await response.text();
                        Logger.error(`‚ùå Request #${requestId} failed: ${response.status} - ${errorText}`);
                        throw new Error(`API request failed: ${response.status} - ${errorText}`);
                    }

                    const data = await response.json();
                    Logger.success(`‚úÖ Request #${requestId} completed successfully`);
                    Logger.debug(`Response data:`);
                    Logger.debug(`- Tokens used: ${data.usage?.total_tokens || 'N/A'}`);
                    Logger.debug(`- Model used: ${data.model || 'N/A'}`);

                    const analysis = data.choices[0].message.content;
                    Logger.debug(`Raw response (first 200 chars): ${analysis.substring(0, 200)}...`);

                    return this.parseAnalysisResponse(analysis, requestId);

                } catch (error) {
                    clearTimeout(timeoutId);

                    if (error.name === 'AbortError') {
                        Logger.error(`‚è∞ Request #${requestId} was aborted (timeout)`);
                        throw new Error(`Analysis timed out after ${timeoutMs/1000} seconds`);
                    } else {
                        Logger.error(`üí• Request #${requestId} failed: ${error.message}`);
                        throw error;
                    }
                }
            }

            // LAYER 2: Question Answering Specialist for 3-page windows
            async analyze3PageWindow(windowText, allQuestions, pageNumbers, maxTokens = null, retryCount = 0, networkRetryCount = 0) {
                const requestId = ++this.requestCount;
                const pageRange = `${pageNumbers[0]}-${pageNumbers[pageNumbers.length - 1]}`;

                // Get max_tokens from settings if not provided
                if (maxTokens === null) {
                    maxTokens = app.settingsManager.get('maxTokensPerRequest') || 3000;
                }

                Logger.api(`üî¨ Layer 2: Analyzing pages ${pageRange} against ALL ${allQuestions.length} questions (attempt ${retryCount + 1}, network retry ${networkRetryCount})`);

                const controller = new AbortController();
                const timeoutMs = 90000; // 90 seconds for comprehensive analysis
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    Logger.error(`‚è∞ Layer 2 request #${requestId} timed out after ${timeoutMs/1000} seconds`);
                }, timeoutMs);

                try {
                    const prompt = this.build3PageWindowPrompt(windowText, allQuestions, pageNumbers);
                    const model = app.settingsManager.get('gptModel');

                    // Enhanced system prompt with industry expertise
                    const systemPrompt = `ROLE DEFINITION:
You are a senior CIPP (Cured-In-Place Pipe) bid analyst and technical expert with deep knowledge of:
- Underground infrastructure rehabilitation standards and specifications
- ASTM standards F1216, F1743, F2019, F2843 for CIPP installation
- Municipal and commercial sewer/stormwater rehabilitation projects
- Contract documents, general conditions, and technical specifications
- CIPP materials: felt tubes, resin systems (polyester, vinyl ester, epoxy), cure methods
- Installation techniques: inversion, pull-in-place, water cure, steam cure, UV cure
- Quality control: CCTV inspection, mandrel testing, pressure testing, flexural testing
- Project risks: bonds, insurance, warranties, liquidated damages, acceptance criteria

OPERATIONAL MODE:
You analyze bid specification documents on behalf of CIPP lining contractors preparing competitive bids. Your analysis must be:
1. EXHAUSTIVE: Every question must be researched thoroughly across the provided pages
2. EVIDENCE-BASED: All answers must quote verbatim from the source document with page citations
3. CONTRACTOR-FOCUSED: Emphasize cost drivers, risk factors, compliance requirements, and bidding constraints
4. PRECISE: Use exact terminology from specifications; bold critical values and requirements
5. CONTEXTUAL: Provide footnotes explaining ambiguities, cross-references, or bid implications

CRITICAL DIRECTIVES:
- Never synthesize, paraphrase, or approximate specification language - quote exactly
- Always include <PDF pg #> markers with quoted text for audit trail
- Mark answers as "Not found in pages X-Y" only when truly absent from the provided window
- Maintain contractor perspective: identify requirements affecting bid price, schedule, risk, or methodology
- Apply 15+ years of CIPP industry knowledge to interpret specifications accurately

OUTPUT FORMAT:
Return ONLY valid JSON matching the exact structure specified in the user prompt. No markdown, no explanatory text, no code blocks.`;

                    // Token estimation and validation (target: <50% of model limit)
                    const estimatedInputTokens = this.estimateTokens(systemPrompt) + this.estimateTokens(prompt);
                    const estimatedTotalTokens = estimatedInputTokens + maxTokens;
                    const modelLimit = this.getModelContextLimit(model);
                    const safeLimit = Math.floor(modelLimit * 0.5); // 50% threshold

                    Logger.debug(`Layer 2 Request #${requestId}:`);
                    Logger.debug(`- Pages: ${pageRange}`);
                    Logger.debug(`- Model: ${model} (limit: ${modelLimit} tokens, safe limit: ${safeLimit} tokens)`);
                    Logger.debug(`- Text length: ${windowText.length} characters`);
                    Logger.debug(`- Questions to analyze: ${allQuestions.length}`);
                    Logger.debug(`- Estimated input tokens: ~${estimatedInputTokens}`);
                    Logger.debug(`- Requested output tokens: ${maxTokens}`);
                    Logger.debug(`- Estimated total: ~${estimatedTotalTokens} tokens`);

                    // Warning if exceeding 50% threshold
                    const percentUsed = Math.round((estimatedTotalTokens / modelLimit) * 100);
                    const percentOfSafe = Math.round((estimatedTotalTokens / safeLimit) * 100);

                    if (estimatedTotalTokens > safeLimit) {
                        Logger.warning(`‚ö†Ô∏è Token usage exceeds 50% threshold! Estimated ${estimatedTotalTokens}/${modelLimit} tokens (${percentUsed}%, safe limit: ${safeLimit})`);
                    } else if (estimatedTotalTokens > modelLimit * 0.9) {
                        Logger.warning(`‚ö†Ô∏è Token usage near absolute limit! Estimated ${estimatedTotalTokens}/${modelLimit} tokens (${percentUsed}%)`);
                    } else {
                        Logger.success(`‚úÖ Token usage OK: ~${estimatedTotalTokens}/${modelLimit} tokens (${percentUsed}%, ${percentOfSafe}% of safe limit)`);
                    }

                    const requestBody = {
                        model: model,
                        messages: [
                            {
                                role: 'system',
                                content: systemPrompt
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: maxTokens,
                        temperature: 0.2
                    };

                    Logger.request(`üì§ Layer 2 sending request #${requestId} to OpenAI`);

                    const startTime = Date.now();
                    const response = await fetch(`${this.baseUrl}/chat/completions`, {
                        method: 'POST',
                        signal: controller.signal,
                        headers: {
                            'Authorization': `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    const requestTime = Date.now() - startTime;
                    Logger.response(`üì• Layer 2 request #${requestId} completed in ${requestTime}ms: ${response.status}`);

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        const errorText = await response.text();
                        Logger.error(`‚ùå Layer 2 request #${requestId} failed: ${response.status} - ${errorText}`);
                        throw new Error(`API request failed: ${response.status} - ${errorText}`);
                    }

                    const data = await response.json();
                    Logger.success(`‚úÖ Layer 2 request #${requestId} successful`);
                    Logger.debug(`- Tokens used: ${data.usage?.total_tokens || 'N/A'}`);

                    const analysis = data.choices[0].message.content;
                    const parsed = this.parse3PageWindowResponse(analysis, requestId);

                    if (parsed && parsed.findings && Array.isArray(parsed.findings)) {
                        Logger.success(`üéØ Layer 2: Extracted ${parsed.findings.length} findings from pages ${pageRange}`);
                        return parsed.findings;
                    } else {
                        Logger.warning(`‚ö†Ô∏è Layer 2: No findings extracted from pages ${pageRange}`);
                        return [];
                    }

                } catch (error) {
                    clearTimeout(timeoutId);

                    // Check error type
                    const errorMsg = error.message.toLowerCase();
                    const isContextError = errorMsg.includes('context') &&
                                          (errorMsg.includes('length') || errorMsg.includes('limit') || errorMsg.includes('exceeded'));
                    const isNetworkError = errorMsg.includes('load failed') ||
                                          errorMsg.includes('network') ||
                                          errorMsg.includes('fetch') ||
                                          error.name === 'TypeError';

                    if (error.name === 'AbortError') {
                        Logger.error(`‚è∞ Layer 2 request #${requestId} timed out`);
                        return [];

                    } else if (isNetworkError && networkRetryCount < 3) {
                        // Network error - retry with exponential backoff
                        const backoffMs = 1000 * Math.pow(2, networkRetryCount); // 1s, 2s, 4s
                        Logger.warning(`‚ö†Ô∏è Network error: ${error.message}`);
                        Logger.info(`üîÑ Network retry ${networkRetryCount + 1}/3 for pages ${pageRange} (waiting ${backoffMs}ms)`);

                        await new Promise(resolve => setTimeout(resolve, backoffMs));

                        // Retry with same parameters but increment network retry count
                        return this.analyze3PageWindow(windowText, allQuestions, pageNumbers, maxTokens, retryCount, networkRetryCount + 1);

                    } else if (isContextError && retryCount < 2) {
                        // Context length error - retry with reduced tokens
                        const newMaxTokens = Math.floor(maxTokens * 0.6); // Reduce by 40%
                        Logger.warning(`‚ö†Ô∏è Context length exceeded! Retrying with reduced tokens: ${newMaxTokens} (was ${maxTokens})`);
                        Logger.info(`üîÑ Token retry ${retryCount + 1}/2 for pages ${pageRange}`);

                        await new Promise(resolve => setTimeout(resolve, 1000));

                        // Retry with smaller max_tokens, reset network retry count
                        return this.analyze3PageWindow(windowText, allQuestions, pageNumbers, newMaxTokens, retryCount + 1, 0);

                    } else {
                        // Final failure after all retries
                        Logger.error(`üí• Layer 2 request #${requestId} failed: ${error.message}`);
                        if (isContextError) {
                            Logger.error(`‚ùå Context limit exceeded even after ${retryCount} retries. Consider upgrading to GPT-4o (128K context).`);
                        } else if (isNetworkError) {
                            Logger.error(`‚ùå Network error persisted after ${networkRetryCount} retries. Check your internet connection.`);
                        }
                        return []; // Return empty array on error, don't stop processing
                    }
                }
            }

            build3PageWindowPrompt(windowText, allQuestions, pageNumbers) {
                const pageRange = `${pageNumbers[0]}-${pageNumbers[pageNumbers.length - 1]}`;

                // Build detailed question list with section headers for context
                const questionList = allQuestions.map(q =>
                    `${q.number}. [${q.section_header}] ${q.question}`
                ).join('\n');

                return `ROLE AND EXPERTISE:
You are a senior CIPP (Cured-In-Place Pipe) project manager and bid analyst with 15+ years of experience in underground infrastructure rehabilitation. You specialize in:
- Sewer and stormwater pipe rehabilitation using CIPP lining methods
- Bid specification analysis for municipal and commercial projects
- Contract risk assessment and compliance verification
- ASTM standards (F1216, F1743, F2019, F2843) and industry best practices
- Installation methods: water cure, steam cure, UV cure
- Materials engineering: polyester, vinyl ester, epoxy resin systems
- Project cost estimation and schedule development

MISSION-CRITICAL OBJECTIVE:
You are analyzing pages ${pageRange} of a CIPP bid specification document on behalf of a CIPP lining contractor preparing to bid on this project. Your analysis MUST be exhaustive, precise, and evidence-based. The contractor's bid accuracy, risk mitigation, and project success depend on your thoroughness.

CONTRACTOR PERSPECTIVE - ANALYZE FOR:
1. Bid Requirements: bonds, insurance, certifications, submission deadlines
2. Technical Specifications: liner materials, thickness, ASTM compliance, cure methods
3. Cost Drivers: linear footage, pipe diameters, bypass pumping, traffic control, permits
4. Installation Constraints: access restrictions, working hours, dewatering requirements
5. Quality Control: testing procedures, acceptance criteria, third-party certification
6. Risk Factors: warranty duration, liquidated damages, defect remediation costs
7. Payment Terms: schedule of values, retention, progress payments
8. Timeline: substantial completion, final completion, penalty clauses

DOCUMENT CONTEXT:
Pages ${pageRange} of CIPP Bid Specification Document

ALL QUESTIONS TO ANALYZE (${allQuestions.length} questions):
${questionList}

DOCUMENT TEXT (Pages ${pageRange}):
${windowText}

CRITICAL ANSWERING INSTRUCTIONS:

1. EXHAUSTIVE SEARCH PROTOCOL:
   - Read through pages ${pageRange} completely for EACH question
   - Look for direct answers, indirect references, and implied information
   - Check tables, appendices, technical specifications, and general conditions
   - If information exists on these pages, you MUST find it

2. ANSWER FORMAT REQUIREMENTS:
   - If answer found: Quote verbatim from the document
   - Include inline page marker: <PDF pg #>
   - Bold critical specifications: **6.5mm minimum thickness**, **ASTM F1216 compliance**
   - Provide inline citation: Section 3.2.1, Appendix B, Technical Specification 02505
   - If NOT found in pages ${pageRange}: State exactly: "Not found in pages ${pageRange}"

3. CITATION AND EVIDENCE STANDARDS:
   - Cite the specific section, clause, or paragraph where information appears
   - Reference applicable standards: ASTM F1216, ASTM F1743, AWWA M28, etc.
   - Include specification section numbers: Division 02, Section 02505, Part 3.2
   - Note if information appears in multiple locations on these pages

4. CONTRACTOR-CRITICAL CONTEXT:
   - Identify specifications that impact cost estimation
   - Flag requirements that affect schedule or methodology
   - Note testing or acceptance criteria that could trigger rework
   - Highlight warranty, bonding, or insurance requirements
   - Extract penalty clauses, liquidated damages, or risk allocation language

5. CONFIDENCE ASSESSMENT:
   - High: Direct, explicit statement in specification
   - Medium: Indirect reference or inferred from related clause
   - Low: Partially addressed or requires clarification from engineer

6. FOOTNOTE GUIDANCE:
   - Always include PDF page number(s) where information was found
   - Always include contract section numbers (e.g., Division 02, Section 02505, Part 3.2.1)
   - Provide additional context that affects bidding decisions
   - Note cross-references to other specification sections
   - Flag ambiguities or items requiring clarification
   - Identify deviations from standard industry practice
   - Format: "Found on <PDF pg #>, Section X.X.X: [additional context]"

JSON OUTPUT STRUCTURE:
Return a JSON object with exactly this structure. Include ALL ${allQuestions.length} questions in your response, even if not found on these pages.

{
  "findings": [
    {
      "question_number": 1,
      "answer": "Verbatim quote from document with <PDF pg #> marker, or 'Not found in pages ${pageRange}'",
      "pdf_page": ${pageNumbers[0]},
      "citation": "Section 3.2.1 - CIPP Material Requirements",
      "confidence": "high",
      "footnote": "Found on <PDF pg ${pageNumbers[0]}>, Section 3.2.1: ASTM F1216 compliance required. Cross-reference General Conditions 00700 for warranty terms affecting this requirement."
    },
    {
      "question_number": 2,
      "answer": "Next answer...",
      "pdf_page": ${pageNumbers[1]},
      "citation": "Technical Specification 02505, Part 2.1",
      "confidence": "medium",
      "footnote": "Found on <PDF pg ${pageNumbers[1]}>, Division 02, Section 02505, Part 2.1: Thickness requirements vary by pipe diameter. See Appendix C Table 1 for calculations."
    }
  ]
}

QUALITY CONTROL REMINDER:
- You are analyzing pages ${pageRange} of a ${windowText.length}-character window
- You must provide responses for all ${allQuestions.length} questions
- Treat "not found" answers as temporary - other pages may contain this information
- Your accuracy directly impacts a contractor's ability to submit a competitive, compliant bid
- Incomplete or imprecise analysis could result in bid rejection or project losses

OUTPUT REQUIREMENT:
Return ONLY the JSON object. Do not include explanatory text, markdown formatting, or code blocks. The JSON must be valid and parseable.`;
            }

            parse3PageWindowResponse(response, requestId = 'unknown') {
                Logger.api(`üîç Layer 2: Parsing response for request #${requestId}`);

                try {
                    // Clean the response
                    let cleanResponse = response.trim();

                    // Remove markdown code blocks if present
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```json\s*/gi, '').replace(/```\s*$/g, '').trim();
                    }

                    // Try to parse JSON
                    const parsed = JSON.parse(cleanResponse);

                    if (parsed.findings && Array.isArray(parsed.findings)) {
                        Logger.success(`‚úÖ Layer 2: Parsed ${parsed.findings.length} findings successfully`);
                        return parsed;
                    } else {
                        Logger.warning(`‚ö†Ô∏è Layer 2: Response missing 'findings' array`);
                        return { findings: [] };
                    }

                } catch (error) {
                    Logger.error(`‚ùå Layer 2: JSON parse failed for request #${requestId}: ${error.message}`);
                    Logger.debug(`Raw response: ${response.substring(0, 500)}...`);
                    return { findings: [] };
                }
            }

            buildSectionPrompt(text, questions, sectionName, chunkNumber, totalChunks) {
                const questionList = questions.map((q, i) => `${i + 1}. ${q}`).join('\\n');

                return `üéØ DOCUMENT ANALYSIS TASK:
You are analyzing a CIPP sewer rehabilitation specification document. Focus on the "${sectionName}" section questions.

üìã INSTRUCTIONS:
1. CAREFULLY READ the entire document text provided
2. FIND answers to each question based ONLY on the document text
3. EXTRACT specific quotes, section references, and page numbers
4. RESPOND with detailed answers or "Not specified in this section" if not found
5. CITE exactly where you found each piece of information

‚ùì ${sectionName.toUpperCase()} QUESTIONS (${questions.length} questions):
${questionList}

üìÑ DOCUMENT TEXT (Chunk ${chunkNumber}/${totalChunks}):
================================================================================
${text}
================================================================================

üéØ REQUIRED JSON RESPONSE (respond ONLY with this JSON format):
{
  "section": "${sectionName}",
  "chunk_info": {
    "chunk_number": ${chunkNumber},
    "total_chunks": ${totalChunks},
    "text_length": ${text.length}
  },
  "answers": [
    {
      "question_number": 1,
      "question": "[exact question text]",
      "answer": "[detailed answer from document or 'Not specified in this section']",
      "citation": "[specific section/page reference]",
      "confidence": "high/medium/low",
      "pdf_page": "[page number if found]",
      "inline_citation": "[exact quote from document]",
      "footnote": "[additional details]"
    }
  ]
}

üö® CRITICAL: Return ONLY the JSON. No other text.`;
            }

            parseAnalysisResponse(response, requestId = 'unknown') {
                Logger.api(`üîç Parsing response for request #${requestId}`);
                Logger.debug(`Raw response length: ${response.length} characters`);

                try {
                    const cleanResponse = response.trim();

                    // Log full response for debugging
                    Logger.debug(`Full response: "${cleanResponse}"`);

                    let parsed = null;

                    // Method 1: Try parsing entire response as JSON
                    try {
                        parsed = JSON.parse(cleanResponse);
                        Logger.success(`‚úÖ Method 1: Parsed entire response as JSON`);
                    } catch (e) {
                        Logger.debug(`Method 1 failed: ${e.message}`);
                    }

                    // Method 2: Look for JSON between ```json and ``` markers
                    if (!parsed) {
                        const codeBlockMatch = cleanResponse.match(/```(?:json)?\\s*([\\s\\S]*?)```/i);
                        if (codeBlockMatch) {
                            try {
                                parsed = JSON.parse(codeBlockMatch[1].trim());
                                Logger.success(`‚úÖ Method 2: Parsed JSON from code block`);
                            } catch (e) {
                                Logger.debug(`Method 2 failed: ${e.message}`);
                            }
                        }
                    }

                    // Method 3: Look for JSON starting with first { and ending with last }
                    if (!parsed) {
                        const firstBrace = cleanResponse.indexOf('{');
                        const lastBrace = cleanResponse.lastIndexOf('}');
                        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
                            try {
                                const jsonCandidate = cleanResponse.substring(firstBrace, lastBrace + 1);
                                parsed = JSON.parse(jsonCandidate);
                                Logger.success(`‚úÖ Method 3: Extracted JSON between braces`);
                            } catch (e) {
                                Logger.debug(`Method 3 failed: ${e.message}`);
                            }
                        }
                    }

                    // Method 4: Try to extract JSON with regex (fixed pattern)
                    if (!parsed) {
                        const jsonMatch = cleanResponse.match(/\\{[\\s\\S]*\\}/);
                        if (jsonMatch) {
                            try {
                                parsed = JSON.parse(jsonMatch[0]);
                                Logger.success(`‚úÖ Method 4: Found and parsed JSON pattern`);
                            } catch (e) {
                                Logger.debug(`Method 4 failed: ${e.message}`);
                            }
                        }
                    }

                    if (parsed) {
                        Logger.debug(`Parsed object keys: ${Object.keys(parsed).join(', ')}`);

                        if (parsed.answers && Array.isArray(parsed.answers)) {
                            Logger.success(`‚úÖ Successfully parsed ${parsed.answers.length} answers from request #${requestId}`);

                            // Validate and clean answer structure
                            const validAnswers = parsed.answers.map(answer => {
                                return {
                                    question_number: answer.question_number || 0,
                                    question: answer.question || 'Unknown question',
                                    answer: answer.answer || 'Not specified in this section',
                                    citation: answer.citation || 'No citation',
                                    confidence: answer.confidence || 'medium',
                                    pdf_page: answer.pdf_page || 'Unknown',
                                    inline_citation: answer.inline_citation || '',
                                    footnote: answer.footnote || ''
                                };
                            });

                            Logger.success(`‚úÖ Validated ${validAnswers.length} answers`);
                            return { ...parsed, answers: validAnswers };
                        } else {
                            Logger.warning(`‚ö†Ô∏è Parsed JSON missing answers array in request #${requestId}`);
                            Logger.debug(`Parsed structure: ${JSON.stringify(parsed, null, 2)}`);
                        }
                    }

                    // If all parsing methods failed, log the full response and return empty
                    Logger.error(`‚ùå All JSON parsing methods failed for request #${requestId}`);
                    Logger.error(`FULL RESPONSE DUMP:`);
                    Logger.error(cleanResponse);
                    return { answers: [], error: 'No valid JSON structure found', raw_response: cleanResponse };

                } catch (error) {
                    Logger.error(`üí• Parse error for request #${requestId}: ${error.message}`);
                    Logger.error(`Error details: ${error.stack}`);
                    return { answers: [], error: error.message };
                }
            }
        }

        // File Parser with proper PDF service integration
        class FileParser {
            async parse(file) {
                const extension = file.name.split('.').pop().toLowerCase();
                Logger.info(`üìÑ Parsing ${extension.toUpperCase()} file: ${file.name} (${(file.size/1024).toFixed(1)} KB)`);

                switch (extension) {
                    case 'pdf':
                        return await this.parsePDF(file);
                    case 'txt':
                    case 'text':
                        return await this.parseText(file);
                    default:
                        Logger.warning(`‚ö†Ô∏è Unsupported file type: ${extension}. Attempting text parsing...`);
                        return await this.parseText(file);
                }
            }

            async parsePDF(file) {
                Logger.api(`üìÑ Using server-side PDF extraction service for: ${file.name}`);

                try {
                    // Check if PDF service is available
                    const statusCheck = await fetch('/cipp-analyzer/api/service-status', {
                        method: 'GET',
                        signal: AbortSignal.timeout(5000)
                    });

                    if (!statusCheck.ok) {
                        throw new Error('PDF extraction service not available');
                    }

                    const statusData = await statusCheck.json();
                    if (!statusData.available) {
                        throw new Error('PDF extraction service is not running');
                    }

                    Logger.success(`‚úÖ PDF service available (${statusData.libraries.join(', ')})`);

                    // Create FormData and upload file
                    const formData = new FormData();
                    formData.append('file', file);

                    Logger.request(`üì§ Uploading PDF to server for extraction (${(file.size/1024).toFixed(1)}KB)...`);

                    const response = await fetch('/cipp-analyzer/api/extract_pdf', {
                        method: 'POST',
                        body: formData,
                        signal: AbortSignal.timeout(120000) // 2 minute timeout for large PDFs
                    });

                    if (!response.ok) {
                        let errorData;
                        try {
                            errorData = await response.json();
                        } catch (e) {
                            errorData = { error: await response.text() };
                        }
                        Logger.error(`‚ùå PDF extraction HTTP error: ${response.status} ${response.statusText}`);
                        Logger.error(`Error details: ${JSON.stringify(errorData)}`);
                        throw new Error(`PDF extraction failed: ${errorData.error || response.statusText}`);
                    }

                    const data = await response.json();

                    if (!data.success) {
                        Logger.error(`‚ùå PDF extraction service reported failure: ${data.error || 'Unknown error'}`);
                        throw new Error(`PDF extraction failed: ${data.error || 'Service reported failure'}`);
                    }

                    // Use combined_text which includes <PDF pg #> markers
                    const extractedText = data.combined_text || data.pages.map(p => p.text).join('\n\n');

                    if (!extractedText || extractedText.length < 10) {
                        Logger.error(`‚ùå Extracted text is too short: ${extractedText ? extractedText.length : 0} characters`);
                        Logger.debug(`Raw extraction result: ${JSON.stringify(data)}`);
                        throw new Error('PDF extraction returned insufficient text. The PDF may be image-based or corrupted.');
                    }

                    Logger.success(`‚úÖ Server extracted ${extractedText.length} characters from ${data.page_count} pages`);
                    Logger.success(`üìä Extraction stats: ${data.total_chars} total characters, ${data.page_count} pages`);
                    Logger.debug(`Text preview (first 300 chars): "${extractedText.substring(0, 300)}..."`);

                    // Additional validation
                    const wordCount = extractedText.split(/\s+/).filter(w => w.length > 0).length;
                    Logger.debug(`üìä Word count: ~${wordCount} words`);

                    const chunkSize = parseInt(document.getElementById('chunkSize').value) || app.settingsManager.get('defaultChunkSize');
                    Logger.info(`üìè Using chunk size: ${chunkSize} characters`);

                    const chunks = this.chunkText(extractedText, chunkSize);

                    Logger.success(`‚úÇÔ∏è Text successfully chunked into ${chunks.length} pieces (target: ${chunkSize} chars per chunk)`);

                    // Log chunk statistics
                    const avgChunkSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0) / chunks.length;
                    Logger.debug(`Chunk stats: ${chunks.length} chunks, avg size: ${avgChunkSize.toFixed(0)} chars`);

                    return chunks;

                } catch (error) {
                    Logger.error(`‚ùå PDF extraction failed: ${error.message}`);
                    if (error.name === 'AbortError') {
                        Logger.error(`‚è∞ PDF extraction timed out - file may be too large or complex`);
                    } else if (error.message.includes('service not available')) {
                        Logger.error(`üö® PDF Service Error: Server-side PDF extraction is not available`);
                        Logger.info(`üí° Please check server logs or contact administrator`);
                    }
                    throw error;
                }
            }

            async parseText(file) {
                return new Promise((resolve, reject) => {
                    Logger.info(`üìù Reading text file: ${file.name}`);

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result;

                            if (!text || text.length === 0) {
                                throw new Error("File appears to be empty");
                            }

                            Logger.success(`üìñ Text loaded: ${text.length} characters`);

                            const chunkSize = parseInt(document.getElementById('chunkSize').value) || app.settingsManager.get('defaultChunkSize');
                            const chunks = this.chunkText(text, chunkSize);

                            Logger.success(`‚úÇÔ∏è Text chunked into ${chunks.length} pieces`);
                            resolve(chunks);

                        } catch (error) {
                            Logger.error(`‚ùå Text parse error: ${error.message}`);
                            reject(error);
                        }
                    };

                    reader.onerror = () => {
                        Logger.error("‚ùå File read error");
                        reject(new Error("Failed to read file"));
                    };

                    reader.readAsText(file);
                });
            }

            async fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            chunkText(text, chunkSize) {
                const chunks = [];
                const words = text.split(/\s+/).filter(w => w.length > 0);
                let currentChunk = '';

                Logger.debug(`üìù Starting chunking: ${text.length} chars, target chunk size: ${chunkSize}`);
                Logger.debug(`üìù Split into ${words.length} words`);

                for (const word of words) {
                    const testChunk = currentChunk + (currentChunk ? ' ' : '') + word;

                    if (testChunk.length <= chunkSize) {
                        currentChunk = testChunk;
                    } else {
                        if (currentChunk.trim()) {
                            chunks.push(currentChunk.trim());
                            Logger.debug(`üì¶ Chunk ${chunks.length}: ${currentChunk.length} characters`);
                        }
                        currentChunk = word;
                    }
                }

                if (currentChunk.trim()) {
                    chunks.push(currentChunk.trim());
                    Logger.debug(`üì¶ Final chunk ${chunks.length}: ${currentChunk.length} characters`);
                }

                Logger.success(`‚úÇÔ∏è Chunked ${words.length} words into ${chunks.length} chunks (target: ${chunkSize} chars each)`);
                return chunks;
            }
        }

        // LAYER 3: Answer Accumulator - Manages the 105-question master list
        class AnswerAccumulator {
            constructor() {
                this.doc_review_glocom = [];  // Master list of all 105 questions
                this.doc_footnotes = [];       // Accumulated footnotes
                this.initialized = false;
            }

            initialize(questionSections) {
                // Build complete 105-question list from sections
                this.doc_review_glocom = [];
                let questionNumber = 1;

                Object.entries(questionSections).forEach(([sectionName, section]) => {
                    if (section.enabled && section.questions) {
                        section.questions.forEach(questionText => {
                            this.doc_review_glocom.push({
                                section_header: sectionName,
                                number: questionNumber++,
                                question: questionText,
                                answer: "Not yet found",
                                pdf_pages: [],
                                inline_citations: [],
                                footnotes: [],
                                confidence: "pending"
                            });
                        });
                    }
                });

                this.initialized = true;
                Logger.success(`‚úÖ Initialized answer accumulator with ${this.doc_review_glocom.length} questions`);
                return this.doc_review_glocom.length;
            }

            accumulateFindings(findings) {
                // findings is an array of answers from Layer 2
                if (!findings || !Array.isArray(findings)) {
                    Logger.warning("No findings to accumulate");
                    return;
                }

                let accumulated = 0;
                findings.forEach(finding => {
                    const questionNum = finding.question_number;
                    if (!questionNum || questionNum < 1 || questionNum > this.doc_review_glocom.length) {
                        Logger.warning(`Invalid question number: ${questionNum}`);
                        return;
                    }

                    const question = this.doc_review_glocom[questionNum - 1];

                    // Check if this is actually a new finding (not "not found")
                    const isNotFound = finding.answer && (
                        finding.answer.toLowerCase().includes("not found") ||
                        finding.answer.toLowerCase().includes("not mentioned") ||
                        finding.answer === "N/A"
                    );

                    if (!isNotFound && finding.answer) {
                        // APPEND to existing answer (never overwrite)
                        if (question.answer === "Not yet found" || question.answer === "") {
                            question.answer = finding.answer;
                        } else {
                            // Append with page marker
                            question.answer += `\n\n**[Additional finding]** ${finding.answer}`;
                        }

                        // Accumulate page numbers (avoid duplicates)
                        if (finding.pdf_page) {
                            const pages = Array.isArray(finding.pdf_page) ? finding.pdf_page : [finding.pdf_page];
                            pages.forEach(page => {
                                if (!question.pdf_pages.includes(page)) {
                                    question.pdf_pages.push(page);
                                }
                            });
                        }

                        // Accumulate citations
                        if (finding.citation || finding.inline_citation) {
                            const citation = finding.citation || finding.inline_citation;
                            if (!question.inline_citations.includes(citation)) {
                                question.inline_citations.push(citation);
                            }
                        }

                        // Add footnotes
                        if (finding.footnote) {
                            question.footnotes.push(finding.footnote);
                            if (!this.doc_footnotes.includes(finding.footnote)) {
                                this.doc_footnotes.push(finding.footnote);
                            }
                        }

                        question.confidence = finding.confidence || "medium";
                        accumulated++;
                    }
                });

                if (accumulated > 0) {
                    Logger.success(`üìù Accumulated ${accumulated} new findings`);
                }

                return accumulated;
            }

            getAnsweredCount() {
                return this.doc_review_glocom.filter(q => q.answer !== "Not yet found").length;
            }

            getCompletionPercentage() {
                return ((this.getAnsweredCount() / this.doc_review_glocom.length) * 100).toFixed(1);
            }

            getCurrentState() {
                return {
                    questions: this.doc_review_glocom,
                    footnotes: this.doc_footnotes,
                    answered: this.getAnsweredCount(),
                    total: this.doc_review_glocom.length,
                    completion: this.getCompletionPercentage()
                };
            }
        }

        // LAYER 4: Unitary Log Compiler/Organizer - Displays and manages the 105-question table
        class UnitaryLogCompiler {
            constructor() {
                this.lastDisplayedPage = 0;
                this.checkpointInterval = 30; // Display every 30 pages
                this.pauseInterval = 50;      // Pause every 50 pages
            }

            shouldDisplayCheckpoint(currentPage) {
                return currentPage > 0 && currentPage % this.checkpointInterval === 0;
            }

            shouldPauseForUser(currentPage) {
                return currentPage > 0 && currentPage % this.pauseInterval === 0;
            }

            displayCurrentState(accumulator, currentPage, totalPages) {
                const state = accumulator.getCurrentState();

                Logger.info(`\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                Logger.info(`üìä UNITARY LOG STATUS - Page ${currentPage}/${totalPages}`);
                Logger.info(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
                Logger.info(`‚úÖ Answered: ${state.answered}/${state.total} questions (${state.completion}%)`);
                Logger.info(`üìÑ Pages processed: ${currentPage}/${totalPages}`);
                Logger.info(`üìù Footnotes collected: ${state.footnotes.length}`);
                Logger.info(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);

                // Display table in results section
                this.renderUnitaryTable(state.questions, state.footnotes, currentPage, totalPages);
            }

            displayCheckpoint(accumulator, currentPage, totalPages) {
                Logger.api(`\nüéØ === CHECKPOINT: ${currentPage} PAGES PROCESSED ===\n`);
                this.displayCurrentState(accumulator, currentPage, totalPages);

                const state = accumulator.getCurrentState();
                Logger.info(`\nüìà Progress Summary:`);
                Logger.info(`   ‚Ä¢ ${state.answered} questions answered`);
                Logger.info(`   ‚Ä¢ ${state.total - state.answered} questions pending`);
                Logger.info(`   ‚Ä¢ ${state.completion}% complete`);
                Logger.info(`\nüîÑ Continuing analysis...`);
            }

            async pauseForUser(accumulator, currentPage, totalPages) {
                Logger.warning(`\n‚è∏Ô∏è  === PAUSE at ${currentPage} pages ===\n`);
                this.displayCurrentState(accumulator, currentPage, totalPages);

                // In the web version, we'll just log this and continue
                // In future, could add a modal dialog
                Logger.info(`‚ÑπÔ∏è  Continuing automatically (pause feature for future enhancement)...`);

                return true; // Continue
            }

            renderUnitaryTable(questions, footnotes, currentPage, totalPages) {
                const resultsSection = document.getElementById('resultsSection');
                const resultsContent = document.getElementById('resultsContent');

                if (!resultsSection || !resultsContent) {
                    Logger.warning("Results section not found in DOM");
                    return;
                }

                let tableHTML = `
                    <div style="margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, #e7f3ff, #f0f7ff); border-radius: 8px; border-left: 4px solid #2196F3;">
                        <h3 style="margin: 0 0 10px 0; color: #1E3A8A;">üìä Unitary Log - Live Analysis</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <strong>Pages Processed:</strong><br>
                                <span style="font-size: 1.5em; color: #5B7FCC;">${currentPage}/${totalPages}</span>
                            </div>
                            <div>
                                <strong>Questions Answered:</strong><br>
                                <span style="font-size: 1.5em; color: #28a745;">${questions.filter(q => q.answer !== "Not yet found").length}/${questions.length}</span>
                            </div>
                            <div>
                                <strong>Completion:</strong><br>
                                <span style="font-size: 1.5em; color: #5B7FCC;">${((questions.filter(q => q.answer !== "Not yet found").length / questions.length) * 100).toFixed(1)}%</span>
                            </div>
                            <div>
                                <strong>Footnotes:</strong><br>
                                <span style="font-size: 1.5em; color: #667eea;">${footnotes.length}</span>
                            </div>
                        </div>
                    </div>

                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <thead style="background: linear-gradient(135deg, #1E3A8A, #5B7FCC); color: white;">
                            <tr>
                                <th style="padding: 12px; text-align: left; border: 1px solid #ddd; width: 15%;">Section Header</th>
                                <th style="padding: 12px; text-align: center; border: 1px solid #ddd; width: 5%;">#</th>
                                <th style="padding: 12px; text-align: left; border: 1px solid #ddd; width: 25%;">Question</th>
                                <th style="padding: 12px; text-align: left; border: 1px solid #ddd; width: 30%;">Answer</th>
                                <th style="padding: 12px; text-align: center; border: 1px solid #ddd; width: 10%;">PDF Pages</th>
                                <th style="padding: 12px; text-align: left; border: 1px solid #ddd; width: 10%;">Citations</th>
                                <th style="padding: 12px; text-align: center; border: 1px solid #ddd; width: 5%;">Footnote</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                questions.forEach((q, index) => {
                    const isAnswered = q.answer !== "Not yet found";
                    const rowStyle = index % 2 === 0 ? 'background: #f8f9fa;' : 'background: white;';
                    const answerStyle = isAnswered ? 'color: #155724; font-weight: 500;' : 'color: #856404; font-style: italic;';

                    tableHTML += `
                        <tr style="${rowStyle}">
                            <td style="padding: 12px; border: 1px solid #ddd; font-weight: 600; color: #1E3A8A;">${q.section_header}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center; font-weight: 600; color: #5B7FCC;">${q.number}</td>
                            <td style="padding: 12px; border: 1px solid #ddd;">${q.question}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; ${answerStyle}">${q.answer}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center; font-family: monospace;">${q.pdf_pages.join(', ') || '-'}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; font-size: 0.9em;">${q.inline_citations.join('; ') || '-'}</td>
                            <td style="padding: 12px; border: 1px solid #ddd; text-align: center;">${q.footnotes.length > 0 ? `^${q.footnotes.length}` : '-'}</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table>';

                // Add footnotes if any
                if (footnotes.length > 0) {
                    tableHTML += `
                        <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                            <h4 style="margin-top: 0; color: #1E3A8A;">üìù Footnotes</h4>
                            <ol style="margin: 10px 0; padding-left: 20px;">
                                ${footnotes.map(f => `<li style="margin: 5px 0;">${f}</li>`).join('')}
                            </ol>
                        </div>
                    `;
                }

                resultsContent.innerHTML = tableHTML;
                resultsSection.style.display = 'block';

                // Enable export button
                document.getElementById('exportBtn').disabled = false;
            }
        }

        // Main Application Controller
        class CIPPAnalyzer {
            constructor() {
                this.settingsManager = new SettingsManager();
                this.apiClient = null;
                this.fileParser = new FileParser();
                this.questionSections = {};
                this.results = [];
                this.allQuestions = []; // Track all questions for live display
                this.currentFile = null;
                this.isAnalyzing = false;
                this.shouldStop = false;
                this.currentChunk = 0;
                this.totalChunks = 0;

                // NEW: Initialize multi-layer architecture
                this.answerAccumulator = new AnswerAccumulator();  // Layer 3
                this.unitaryLogCompiler = new UnitaryLogCompiler(); // Layer 4
                this.pdfPages = [];  // Store PDF pages with numbers (Layer 1 output)
                this.currentPageIndex = 0;

                this.initializeEventListeners();
                this.loadDefaultQuestions();
                this.initializeWithApiKey();
                this.checkPdfService();
                Logger.success("üöÄ CIPP Spec Analyzer with Multi-Layer AI Architecture initialized");
            }

            async checkPdfService() {
                try {
                    const response = await fetch('/cipp-analyzer/api/service-status', {
                        method: 'GET',
                        signal: AbortSignal.timeout(3000)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const serviceStatus = document.getElementById('serviceStatus');
                        const serviceStatusText = document.getElementById('serviceStatusText');

                        if (data.available) {
                            serviceStatus.className = 'service-status service-running';
                            const formats = data.supported_formats ? data.supported_formats.join(', ') : 'PDF';
                            serviceStatusText.textContent = `‚úÖ Document Service: Running (${formats})`;
                            Logger.success(`‚úÖ Document extraction service is running. Supported: ${formats}`);
                        } else {
                            throw new Error('Service not available');
                        }
                    } else {
                        throw new Error('Service not responding');
                    }
                } catch (error) {
                    const serviceStatus = document.getElementById('serviceStatus');
                    const serviceStatusText = document.getElementById('serviceStatusText');
                    serviceStatus.className = 'service-status service-stopped';
                    serviceStatusText.textContent = '‚ö†Ô∏è Document Service: Unavailable - Check server logs';
                    Logger.warning(`‚ö†Ô∏è Document service not available: ${error.message}`);
                }
            }

            async initializeWithApiKey() {
                try {
                    // Fetch API key from backend environment
                    const response = await fetch('/api/config/apikey', {
                        method: 'GET',
                        signal: AbortSignal.timeout(5000)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.key) {
                            // Configure API with the fetched key
                            await this.configureApi(data.key);

                            // Update UI
                            const apiStatusText = document.getElementById('apiStatusText');
                            apiStatusText.textContent = `‚úÖ API Key Configured (${data.masked})`;
                            apiStatusText.style.color = '#28a745';

                            Logger.success(`‚úÖ API key loaded from environment: ${data.masked}`);
                        } else {
                            throw new Error(data.error || 'Failed to load API key');
                        }
                    } else {
                        throw new Error('Failed to fetch API key from server');
                    }
                } catch (error) {
                    const apiStatusText = document.getElementById('apiStatusText');
                    apiStatusText.textContent = `‚ö†Ô∏è API Key Not Configured - ${error.message}`;
                    apiStatusText.style.color = '#dc3545';
                    Logger.error(`‚ùå Failed to load API key: ${error.message}`);
                }

                // Set default chunk size
                const chunkSizeInput = document.getElementById('chunkSize');
                if (chunkSizeInput) {
                    chunkSizeInput.value = this.settingsManager.get('defaultChunkSize');
                }
            }

            initializeEventListeners() {
                const fileUpload = document.getElementById('fileUpload');

                fileUpload.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    fileUpload.classList.add('dragover');
                });

                fileUpload.addEventListener('dragleave', () => {
                    fileUpload.classList.remove('dragover');
                });

                fileUpload.addEventListener('drop', (e) => {
                    e.preventDefault();
                    fileUpload.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFileSelect({ target: { files } });
                    }
                });
            }

            loadDefaultQuestions() {
                // Try to load from storage first
                if (this.loadQuestionsFromStorage()) {
                    this.updateQuestionSectionUI();
                    this.updateActiveQuestionCount();
                    Logger.success(`Loaded saved questions: ${this.getTotalQuestionCount()} questions`);
                    return;
                }

                // Use comprehensive default questions
                this.questionSections = {
                    "Project Information": {
                        enabled: true,
                        questions: [
                            "What is the project name and location?",
                            "Who is the owner/agency for this project?",
                            "What is the engineer of record?",
                            "What are the project contract dates?",
                            "What is the total project value or estimated cost?",
                            "What are the liquidated damages specified?",
                            "What is the project scope and description?",
                            "Are there multiple bid items or phases?",
                            "What are the key project milestones?",
                            "What permits or approvals are required?"
                        ]
                    },
                    "Pipe Specifications": {
                        enabled: true,
                        questions: [
                            "What pipe diameters are being rehabilitated?",
                            "What is the existing pipe material (concrete, clay, PVC, etc.)?",
                            "What is the total linear footage to be lined?",
                            "What are the pipe classifications or structural conditions?",
                            "Are there different pipe sizes in the same run?",
                            "What is the minimum and maximum pipe diameter?",
                            "Are there any pipe material restrictions?",
                            "What is the existing pipe wall thickness?",
                            "Are there any pipe alignment or grade requirements?",
                            "What existing pipe conditions must be documented?"
                        ]
                    },
                    "CIPP Liner Requirements": {
                        enabled: true,
                        questions: [
                            "What CIPP liner material is specified (polyester, vinyl ester, epoxy)?",
                            "What is the minimum liner wall thickness required?",
                            "What are the liner strength requirements (flexural, tensile)?",
                            "What curing method is specified (steam, hot water, UV, ambient)?",
                            "What is the required curing temperature and duration?",
                            "What are the liner deflection limits after installation?",
                            "Are there specific resin requirements?",
                            "What liner manufacturing standards must be met?",
                            "Are there flame retardant requirements?",
                            "What is the required liner service life?"
                        ]
                    },
                    "Pre-Installation Work": {
                        enabled: true,
                        questions: [
                            "What cleaning methods are required before installation?",
                            "Are root cutting or removal services specified?",
                            "What debris removal requirements exist?",
                            "Are high-pressure water jetting requirements specified?",
                            "What surface preparation is required?",
                            "Are there specific cleaning equipment requirements?",
                            "What inspection requirements exist before installation?",
                            "Are bypass pumping requirements specified?",
                            "What traffic control measures are required?",
                            "Are there specific access requirements?"
                        ]
                    },
                    "Installation Process": {
                        enabled: true,
                        questions: [
                            "What installation method is specified (inversion, pull-in-place)?",
                            "Are there specific installation equipment requirements?",
                            "What are the environmental conditions for installation?",
                            "Are there temperature or weather restrictions?",
                            "What safety requirements are specified during installation?",
                            "Are there specific crew certification requirements?",
                            "What installation rate or production requirements exist?",
                            "Are there noise or time restrictions?",
                            "What utilities protection measures are required?",
                            "Are there specific staging area requirements?"
                        ]
                    },
                    "Quality Control & Testing": {
                        enabled: true,
                        questions: [
                            "What pre-installation testing is required?",
                            "What post-installation testing procedures are specified?",
                            "Are deflection tests required and at what intervals?",
                            "What pressure testing requirements exist?",
                            "Are there specific inspection requirements?",
                            "What documentation must be provided?",
                            "Are third-party inspections required?",
                            "What testing equipment must be used?",
                            "Are there specific testing standards referenced?",
                            "What happens if testing fails specifications?"
                        ]
                    },
                    "Warranty & Maintenance": {
                        enabled: true,
                        questions: [
                            "What is the warranty period for the CIPP installation?",
                            "What does the warranty cover specifically?",
                            "Are there warranty exclusions specified?",
                            "What maintenance requirements exist during warranty?",
                            "Who is responsible for warranty service?",
                            "Are there performance bonds required?",
                            "What insurance requirements are specified?",
                            "Are there specific warranty documentation requirements?",
                            "What remedy procedures exist for warranty claims?",
                            "Are there extended warranty options available?"
                        ]
                    },
                    "Environmental & Safety": {
                        enabled: true,
                        questions: [
                            "What environmental protection measures are required?",
                            "Are there specific safety protocols for confined spaces?",
                            "What air monitoring requirements exist?",
                            "Are there noise level restrictions?",
                            "What waste disposal requirements are specified?",
                            "Are there groundwater protection measures?",
                            "What emergency response procedures are required?",
                            "Are there specific PPE requirements?",
                            "What environmental permits are required?",
                            "Are there seasonal or timing restrictions?"
                        ]
                    },
                    "Payment & Documentation": {
                        enabled: true,
                        questions: [
                            "How is the work measured for payment?",
                            "What unit prices are specified?",
                            "Are there mobilization costs included?",
                            "What documentation is required for payment?",
                            "Are there progress payment schedules?",
                            "What final acceptance criteria exist?",
                            "Are there retainage requirements?",
                            "What change order procedures are specified?",
                            "Are there specific invoicing requirements?",
                            "What final documentation must be submitted?"
                        ]
                    },
                    "Special Conditions": {
                        enabled: true,
                        questions: [
                            "Are there any unique or special requirements?",
                            "Are there specific material sourcing requirements?",
                            "Are there local preference or DBE requirements?",
                            "What special equipment or techniques are required?",
                            "Are there specific training or certification requirements?",
                            "Are there unusual access or logistics challenges?",
                            "What coordination with other trades is required?",
                            "Are there phasing or staging requirements?",
                            "What are the project-specific technical specifications?",
                            "Are there any innovative or pilot technologies specified?"
                        ]
                    }
                };

                this.updateQuestionSectionUI();
                this.updateActiveQuestionCount();
                Logger.success(`Loaded ${this.getTotalQuestionCount()} questions in ${Object.keys(this.questionSections).length} sections`);
            }

            getTotalQuestionCount() {
                return Object.values(this.questionSections)
                    .reduce((total, section) => total + section.questions.length, 0);
            }

            getActiveQuestions() {
                const activeQuestions = [];

                Object.entries(this.questionSections).forEach(([sectionName, section]) => {
                    if (section.enabled && section.questions) {
                        section.questions.forEach((question) => {
                            activeQuestions.push({
                                question: question,
                                section: sectionName
                            });
                        });
                    }
                });

                return activeQuestions;
            }

            getActiveSections() {
                const activeSections = {};

                Object.entries(this.questionSections).forEach(([sectionName, section]) => {
                    if (section.enabled && section.questions) {
                        activeSections[sectionName] = section.questions;
                    }
                });

                return activeSections;
            }

            updateActiveQuestionCount() {
                const activeCount = this.getActiveQuestions().length;
                document.getElementById('activeQuestionCount').textContent = activeCount;

                const analyzeBtn = document.getElementById('analyzeBtn');
                analyzeBtn.disabled = !(this.currentFile && this.apiClient && activeCount > 0);
            }

            updateQuestionSectionUI() {
                const container = document.getElementById('questionSections');
                container.innerHTML = '';

                Object.entries(this.questionSections).forEach(([sectionName, section]) => {
                    const sectionDiv = document.createElement('div');
                    sectionDiv.className = `question-section ${section.enabled ? 'enabled' : 'disabled'}`;
                    sectionDiv.onclick = () => this.toggleQuestionSection(sectionName);

                    sectionDiv.innerHTML = `
                        <div class="section-header">
                            <span>${sectionName}</span>
                            <span class="section-count">${section.questions.length}</span>
                        </div>
                        <div style="font-size: 12px; color: #666;">
                            ${section.enabled ? 'Enabled' : 'Disabled'} ‚Ä¢ Click to toggle
                        </div>
                    `;
                    container.appendChild(sectionDiv);
                });

                this.updateActiveQuestionCount();
            }

            toggleQuestionSection(sectionName) {
                if (this.questionSections[sectionName]) {
                    this.questionSections[sectionName].enabled = !this.questionSections[sectionName].enabled;
                    this.updateQuestionSectionUI();
                    Logger.info(`${sectionName} section ${this.questionSections[sectionName].enabled ? 'enabled' : 'disabled'}`);
                }
            }

            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.currentFile = file;
                const extension = file.name.split('.').pop().toLowerCase();
                const sizeKB = (file.size / 1024).toFixed(1);
                const sizeMB = (file.size / 1024 / 1024).toFixed(2);

                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileSize').textContent = sizeMB > 1 ? `${sizeMB} MB` : `${sizeKB} KB`;
                document.getElementById('fileInfo').style.display = 'block';

                if (extension === 'pdf') {
                    Logger.success(`üìÑ PDF file selected: ${file.name}`);
                    Logger.info(`üîç Will use server-side PDF extraction service`);
                } else {
                    Logger.success(`üìÑ ${extension.toUpperCase()} file selected: ${file.name}`);
                }

                if (this.apiClient) {
                    document.getElementById('analyzeBtn').disabled = false;
                }

                Logger.info(`üìÅ File ready for analysis: ${file.name}`);
            }

            async configureApi(apiKey) {
                this.apiClient = new OpenAIClient(apiKey);
                const isConnected = await this.apiClient.testConnection();

                const statusIndicator = document.getElementById('apiStatus');
                if (isConnected) {
                    statusIndicator.className = 'status-indicator status-ready';
                    this.updateActiveQuestionCount();
                } else {
                    statusIndicator.className = 'status-indicator status-error';
                }

                return isConnected;
            }

            async startAnalysis() {
                if (!this.currentFile || !this.apiClient) {
                    Logger.error("File and API configuration required");
                    return;
                }

                const activeSections = this.getActiveSections();
                if (Object.keys(activeSections).length === 0) {
                    Logger.error("No active question sections selected");
                    return;
                }

                try {
                    this.isAnalyzing = true;
                    this.shouldStop = false;
                    this.currentPageIndex = 0;

                    document.getElementById('analyzeBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    ProgressTracker.show();
                    ProgressTracker.update(0, "Starting multi-layer AI analysis...");

                    Logger.api(`\nüöÄ ========== MULTI-LAYER AI PROCESSING INITIATED ==========`);
                    Logger.api(`üìÑ Document: ${this.currentFile.name}`);
                    Logger.api(`üèóÔ∏è Architecture: 4-Layer Specialized Processing`);

                    // STEP 1: Extract PDF with page numbers (Layer 1)
                    Logger.api(`\nüìÑ LAYER 1: Extracting PDF with page number preservation...`);
                    ProgressTracker.update(5, "Layer 1: Extracting PDF pages...");

                    // Get PDF data with page numbers from server
                    const formData = new FormData();
                    formData.append('file', this.currentFile);

                    const pdfResponse = await fetch('/cipp-analyzer/api/extract_pdf', {
                        method: 'POST',
                        body: formData
                    });

                    if (!pdfResponse.ok) {
                        throw new Error('PDF extraction failed');
                    }

                    const pdfData = await pdfResponse.json();
                    this.pdfPages = pdfData.pages; // Array of {page: num, text: string}
                    const totalPages = this.pdfPages.length;

                    Logger.success(`‚úÖ Layer 1: Extracted ${totalPages} pages successfully`);
                    Logger.debug(`Total characters: ${pdfData.total_chars}`);

                    // STEP 2: Initialize Answer Accumulator with ALL questions (Layer 3)
                    Logger.api(`\nüìã LAYER 3: Initializing Answer Accumulator with ALL questions...`);
                    ProgressTracker.update(10, "Layer 3: Initializing 105-question master list...");

                    const totalQuestions = this.answerAccumulator.initialize(this.questionSections);
                    Logger.success(`‚úÖ Layer 3: Initialized with ${totalQuestions} questions`);

                    // STEP 3: Process document in 3-page windows
                    Logger.api(`\nüî¨ LAYER 2: Starting 3-page window analysis...`);
                    Logger.api(`üìä Processing: ${totalPages} pages in ${Math.ceil(totalPages / 3)} windows`);
                    Logger.api(`‚ùì Questions per window: ${totalQuestions}`);
                    Logger.api(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);

                    let windowCount = 0;
                    const totalWindows = Math.ceil(totalPages / 3);

                    for (let pageIndex = 0; pageIndex < totalPages && !this.shouldStop; pageIndex += 3) {
                        windowCount++;
                        this.currentPageIndex = pageIndex;

                        // Get 3-page window
                        const windowPages = this.pdfPages.slice(pageIndex, pageIndex + 3);
                        const pageNumbers = windowPages.map(p => p.page);
                        const windowText = windowPages.map(p => `<PDF pg ${p.page}>\n${p.text}`).join('\n\n');

                        const pageRange = `${pageNumbers[0]}-${pageNumbers[pageNumbers.length - 1]}`;
                        Logger.info(`\n‚îå‚îÄ‚îÄ‚îÄ Window ${windowCount}/${totalWindows}: Pages ${pageRange} ‚îÄ‚îÄ‚îÄ‚îê`);

                        // Update progress
                        const progressPct = (pageIndex / totalPages) * 80;
                        ProgressTracker.update(progressPct, `Window ${windowCount}/${totalWindows}: Analyzing pages ${pageRange}...`);

                        // LAYER 2: Analyze this 3-page window against ALL questions
                        const findings = await this.apiClient.analyze3PageWindow(
                            windowText,
                            this.answerAccumulator.doc_review_glocom,
                            pageNumbers
                        );

                        // LAYER 3: Accumulate findings (APPEND, never overwrite)
                        const accumulated = this.answerAccumulator.accumulateFindings(findings);

                        const currentPage = pageIndex + windowPages.length;
                        Logger.info(`‚îî‚îÄ‚îÄ‚îÄ Accumulated ${accumulated} findings from pages ${pageRange} ‚îÄ‚îÄ‚îÄ‚îò\n`);

                        // LAYER 4: Display every 3 pages (after each window)
                        this.unitaryLogCompiler.displayCurrentState(
                            this.answerAccumulator,
                            currentPage,
                            totalPages
                        );

                        // LAYER 4: Checkpoint display every 30 pages
                        if (this.unitaryLogCompiler.shouldDisplayCheckpoint(currentPage)) {
                            this.unitaryLogCompiler.displayCheckpoint(
                                this.answerAccumulator,
                                currentPage,
                                totalPages
                            );
                        }

                        // LAYER 4: Pause every 50 pages
                        if (this.unitaryLogCompiler.shouldPauseForUser(currentPage)) {
                            const shouldContinue = await this.unitaryLogCompiler.pauseForUser(
                                this.answerAccumulator,
                                currentPage,
                                totalPages
                            );
                            if (!shouldContinue) {
                                this.shouldStop = true;
                                break;
                            }
                        }

                        // Rate limiting delay between windows
                        if (pageIndex + 3 < totalPages && !this.shouldStop) {
                            const delay = this.settingsManager.get('rateLimitDelay') || 2000;
                            Logger.debug(`‚è≥ Rate limit delay: ${delay}ms`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }

                    // FINAL: Display complete unitary log
                    Logger.api(`\n\nüéâ ========== ANALYSIS COMPLETE ==========`);
                    ProgressTracker.update(90, "Finalizing unitary log...");

                    const finalState = this.answerAccumulator.getCurrentState();
                    Logger.info(`\nüìä FINAL STATISTICS:`);
                    Logger.info(`   ‚Ä¢ Total Questions: ${finalState.total}`);
                    Logger.info(`   ‚Ä¢ Questions Answered: ${finalState.answered}`);
                    Logger.info(`   ‚Ä¢ Completion: ${finalState.completion}%`);
                    Logger.info(`   ‚Ä¢ Footnotes Collected: ${finalState.footnotes.length}`);
                    Logger.info(`   ‚Ä¢ Pages Processed: ${this.pdfPages.length}`);

                    // Display final unitary log via Layer 4
                    this.unitaryLogCompiler.displayCurrentState(
                        this.answerAccumulator,
                        this.pdfPages.length,
                        this.pdfPages.length
                    );

                    ProgressTracker.update(100, "Analysis complete!");
                    Logger.success(`\n‚úÖ Multi-layer AI processing completed successfully!`);
                    Logger.api(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);

                    // Store results for export
                    this.results = finalState.questions;
                    this.totalChunks = totalWindows;

                    setTimeout(() => {
                        ProgressTracker.hide();
                    }, 3000);

                } catch (error) {
                    Logger.error(`Analysis failed: ${error.message}`);
                    ProgressTracker.hide();
                } finally {
                    this.isAnalyzing = false;
                    document.getElementById('analyzeBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    if (this.results.length > 0) {
                        document.getElementById('exportBtn').disabled = false;
                    }
                }
            }

            stopAnalysis() {
                if (this.isAnalyzing) {
                    this.shouldStop = true;
                    Logger.warning(`‚èπÔ∏è Stopping analysis... (current chunk: ${this.currentChunk}/${this.totalChunks})`);
                    document.getElementById('stopBtn').disabled = true;
                }
            }

            async synthesizeResults() {
                const grouped = {};
                this.results.forEach(result => {
                    const question = result.question || 'Unknown';
                    if (!grouped[question]) {
                        grouped[question] = [];
                    }
                    grouped[question].push(result);
                });

                this.results = Object.keys(grouped).map(question => {
                    const answers = grouped[question];
                    if (answers.length === 1) {
                        return answers[0];
                    }

                    const combinedAnswer = answers
                        .map(a => a.answer)
                        .filter(a => a && !a.includes("Not specified"))
                        .join("; ");

                    const combinedCitation = answers
                        .map(a => a.citation)
                        .filter(c => c && c !== "No citation")
                        .join(", ");

                    return {
                        question,
                        answer: combinedAnswer || "Not specified in document",
                        citation: combinedCitation || "No citation",
                        confidence: "synthesized",
                        section: answers[0].section
                    };
                });

                Logger.success("Results synthesized");
            }

            initializeLiveResults() {
                // Initialize live results table with all questions
                this.allQuestions = [];

                Object.entries(this.getActiveSections()).forEach(([sectionName, questions]) => {
                    questions.forEach((question, index) => {
                        this.allQuestions.push({
                            section: sectionName,
                            question_number: index + 1,
                            question: question,
                            answer: "Not yet found.",
                            citation: "Pending analysis...",
                            confidence: "pending",
                            pdf_page: "-",
                            status: "pending"
                        });
                    });
                });

                this.updateLiveResultsDisplay();
                document.getElementById('resultsSection').style.display = 'block';
                Logger.info(`üîÑ Initialized live results table with ${this.allQuestions.length} questions`);
            }

            updateLiveResultsDisplay() {
                const liveTable = document.getElementById('liveResultsTable');

                let tableHTML = `
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <thead style="background: #5B7FCC; color: white;">
                            <tr>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Section</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #5a67d8;">#</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Question</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Answer</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Citation</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #5a67d8;">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                this.allQuestions.forEach((question, index) => {
                    const statusColor = {
                        'pending': '#ffc107',
                        'found': '#28a745',
                        'not_found': '#6c757d'
                    }[question.status] || '#6c757d';

                    const rowStyle = index % 2 === 0 ? 'background: #f8f9fa;' : 'background: white;';

                    tableHTML += `
                        <tr style="${rowStyle} border-bottom: 1px solid #dee2e6;" id="question-row-${index}">
                            <td style="padding: 12px; font-weight: 500; color: #333;">${question.section}</td>
                            <td style="padding: 12px; text-align: center; font-weight: bold; color: #5B7FCC;">${question.question_number}</td>
                            <td style="padding: 12px; max-width: 300px;">
                                <div style="font-weight: 500; color: #333;">${question.question}</div>
                            </td>
                            <td style="padding: 12px; max-width: 400px;">
                                <div style="line-height: 1.4; color: ${question.status === 'found' ? '#155724' : '#6c757d'};">${question.answer}</div>
                            </td>
                            <td style="padding: 12px; max-width: 250px;">
                                <div style="font-style: italic; color: #666; font-size: 14px;">${question.citation}</div>
                            </td>
                            <td style="padding: 12px; text-align: center;">
                                <span style="display: inline-block; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; color: white; background: ${statusColor};">
                                    ${question.status}
                                </span>
                            </td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table>';

                // Add summary
                const foundCount = this.allQuestions.filter(q => q.status === 'found').length;
                const summary = `
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                        <h4>üìä Live Analysis Progress</h4>
                        <p><strong>Questions Found:</strong> ${foundCount} / ${this.allQuestions.length}</p>
                        <p><strong>Progress:</strong> ${((foundCount / this.allQuestions.length) * 100).toFixed(1)}%</p>
                        <p><strong>Document:</strong> ${this.currentFile?.name || 'Unknown'}</p>
                        <p><strong>Status:</strong> ${this.isAnalyzing ? 'Analyzing...' : 'Ready'}</p>
                    </div>
                `;

                liveTable.innerHTML = tableHTML + summary;
            }

            updateQuestionAnswer(sectionName, questionText, answer) {
                // Find and update the question in the live table
                const questionIndex = this.allQuestions.findIndex(q =>
                    q.section === sectionName && q.question === questionText
                );

                if (questionIndex !== -1) {
                    this.allQuestions[questionIndex] = {
                        ...this.allQuestions[questionIndex],
                        answer: answer.answer || "Not specified in this section",
                        citation: answer.citation || "No citation",
                        pdf_page: answer.pdf_page || "Unknown",
                        confidence: answer.confidence || "medium",
                        status: answer.answer && !answer.answer.toLowerCase().includes('not specified') ? 'found' : 'not_found'
                    };

                    // Update just this row for better performance
                    const row = document.getElementById(`question-row-${questionIndex}`);
                    if (row) {
                        const statusColor = {
                            'found': '#28a745',
                            'not_found': '#6c757d'
                        }[this.allQuestions[questionIndex].status];

                        row.innerHTML = `
                            <td style="padding: 12px; font-weight: 500; color: #333;">${this.allQuestions[questionIndex].section}</td>
                            <td style="padding: 12px; text-align: center; font-weight: bold; color: #5B7FCC;">${this.allQuestions[questionIndex].question_number}</td>
                            <td style="padding: 12px; max-width: 300px;">
                                <div style="font-weight: 500; color: #333;">${this.allQuestions[questionIndex].question}</div>
                            </td>
                            <td style="padding: 12px; max-width: 400px;">
                                <div style="line-height: 1.4; color: ${this.allQuestions[questionIndex].status === 'found' ? '#155724' : '#6c757d'};">${this.allQuestions[questionIndex].answer}</div>
                            </td>
                            <td style="padding: 12px; max-width: 250px;">
                                <div style="font-style: italic; color: #666; font-size: 14px;">${this.allQuestions[questionIndex].citation}</div>
                            </td>
                            <td style="padding: 12px; text-align: center;">
                                <span style="display: inline-block; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; color: white; background: ${statusColor};">
                                    ${this.allQuestions[questionIndex].status}
                                </span>
                            </td>
                        `;
                    }

                    // Update summary
                    this.updateLiveResultsDisplay();
                    Logger.success(`üìù Updated answer for: ${questionText.substring(0, 50)}...`);
                } else {
                    Logger.warning(`‚ùì Could not find question to update: ${questionText.substring(0, 50)}...`);
                }
            }

            displayResults() {
                const resultsContent = document.getElementById('resultsContent');
                resultsContent.innerHTML = '';

                if (this.results.length === 0) {
                    resultsContent.innerHTML = '<p>No results to display.</p>';
                    return;
                }

                // Create enhanced table
                let tableHTML = `
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <thead style="background: #5B7FCC; color: white;">
                            <tr>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Section</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #5a67d8;">#</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Question</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Answer</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #5a67d8;">Citation</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #5a67d8;">Confidence</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #5a67d8;">Chunk</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                this.results.forEach((result, index) => {
                    const confidenceColor = {
                        'high': '#28a745',
                        'medium': '#ffc107',
                        'low': '#dc3545',
                        'synthesized': '#6f42c1',
                        'error': '#dc3545'
                    }[result.confidence] || '#6c757d';

                    const rowStyle = index % 2 === 0 ? 'background: #f8f9fa;' : 'background: white;';

                    // Special styling for raw responses
                    const isRawResponse = result.is_raw_response;
                    const rowBorder = isRawResponse ? 'border-left: 4px solid #dc3545;' : '';

                    tableHTML += `
                        <tr style="${rowStyle} border-bottom: 1px solid #dee2e6; ${rowBorder}">
                            <td style="padding: 12px; font-weight: 500; color: ${isRawResponse ? '#dc3545' : '#333'};">${result.section || 'Other'}</td>
                            <td style="padding: 12px; text-align: center; font-weight: bold; color: #5B7FCC;">${result.question_number || index + 1}</td>
                            <td style="padding: 12px; max-width: 300px;">
                                <div style="font-weight: 500; color: ${isRawResponse ? '#dc3545' : '#333'};">${result.question}</div>
                            </td>
                            <td style="padding: 12px; max-width: 400px;">
                                ${isRawResponse ?
                                    `<div style="background: #f8d7da; padding: 10px; border-radius: 4px; border: 1px solid #f5c6cb;">
                                        <strong style="color: #721c24;">‚ö†Ô∏è JSON Parsing Failed - Raw ChatGPT Response:</strong><br>
                                        <pre style="white-space: pre-wrap; margin-top: 10px; font-size: 12px; color: #721c24;">${result.answer.replace('PARSING FAILED - Raw ChatGPT Response: ', '')}</pre>
                                    </div>` :
                                    `<div style="line-height: 1.4; color: #555;">${result.answer}</div>`
                                }
                            </td>
                            <td style="padding: 12px; max-width: 250px;">
                                <div style="font-style: italic; color: #666; font-size: 14px;">${result.citation || 'No citation'}</div>
                            </td>
                            <td style="padding: 12px; text-align: center;">
                                <span style="display: inline-block; padding: 4px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; color: white; background: ${confidenceColor};">
                                    ${result.confidence}
                                </span>
                            </td>
                            <td style="padding: 12px; text-align: center; font-family: monospace; color: #666;">${result.chunk_number || '-'}</td>
                        </tr>
                    `;
                });

                tableHTML += '</tbody></table>';

                // Add summary
                const summary = `
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                        <h4>üìä Analysis Summary</h4>
                        <p><strong>Total Results:</strong> ${this.results.length}</p>
                        <p><strong>Document:</strong> ${this.currentFile?.name || 'Unknown'}</p>
                        <p><strong>Status:</strong> ${this.shouldStop ? `Stopped at chunk ${this.currentChunk}/${this.totalChunks}` : 'Completed'}</p>
                        <p><strong>Sections Analyzed:</strong> ${Object.keys(this.getActiveSections()).join(', ')}</p>
                    </div>
                `;

                resultsContent.innerHTML = tableHTML + summary;
                document.getElementById('resultsSection').style.display = 'block';
                Logger.success(`üìã Displayed ${this.results.length} results`);
            }

            async exportResults(format = 'csv') {
                if (this.results.length === 0) {
                    Logger.warning("No results to export");
                    return;
                }

                // Hide export menu
                document.getElementById('exportMenu').style.display = 'none';

                const timestamp = new Date().toISOString().split('T')[0];
                const filename = `cipp_analysis_${timestamp}`;

                // Sort results by section and question number
                const sortedResults = [...this.results].sort((a, b) => {
                    const sectionCompare = (a.section || '').localeCompare(b.section || '');
                    if (sectionCompare !== 0) return sectionCompare;
                    return (a.question_number || 0) - (b.question_number || 0);
                });

                let content, mimeType, extension;

                switch (format) {
                    case 'csv':
                        content = this.exportAsCSV(sortedResults);
                        mimeType = 'text/csv;charset=utf-8;';
                        extension = 'csv';
                        break;
                    case 'markdown':
                        content = this.exportAsMarkdown(sortedResults);
                        mimeType = 'text/markdown;charset=utf-8;';
                        extension = 'md';
                        break;
                    case 'html':
                        content = this.exportAsHTML(sortedResults);
                        mimeType = 'text/html;charset=utf-8;';
                        extension = 'html';
                        break;
                    case 'json':
                        content = this.exportAsJSON(sortedResults);
                        mimeType = 'application/json;charset=utf-8;';
                        extension = 'json';
                        break;
                    default:
                        Logger.error(`Unknown export format: ${format}`);
                        return;
                }

                // Create and trigger download
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.${extension}`;

                // Mobile-friendly download trigger
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Clean up
                setTimeout(() => URL.revokeObjectURL(url), 100);

                Logger.success(`üìä Results exported as ${format.toUpperCase()} file: ${filename}.${extension}`);
            }

            exportAsCSV(results) {
                // Professional CSV format following promptbase.md specification
                const header = ['"Section Header"', '"#"', '"Question"', '"Answer"', '"PDF Page"', '"Inline Citation"', '"Footnote"'].join(',');

                const rows = results.map(result => {
                    return [
                        `"${this.escapeCsvField(result.section || 'N/A')}"`,
                        `"${result.question_number || ''}"`,
                        `"${this.escapeCsvField(result.question || 'N/A')}"`,
                        `"${this.escapeCsvField(result.answer || 'No answer found')}"`,
                        `"${this.escapeCsvField(result.pdf_page || result.chunk_number ? `Chunk ${result.chunk_number}` : 'N/A')}"`,
                        `"${this.escapeCsvField(result.citation || 'N/A')}"`,
                        `"${this.escapeCsvField(result.footnote || '')}"`,
                    ].join(',');
                });

                return [header, ...rows].join('\n');
            }

            exportAsMarkdown(results) {
                // Professional Markdown table format per promptbase.md
                let md = `# CIPP Bid-Spec Analysis Report\n\n`;
                md += `**Generated:** ${new Date().toLocaleString()}\n`;
                md += `**Document:** ${this.currentFile?.name || 'Unknown'}\n`;
                md += `**Total Results:** ${results.length}\n\n`;
                md += `---\n\n`;

                // Table header
                md += `| Section Header | # | Question | Answer | PDF Page | Inline Citation | Footnote |\n`;
                md += `|----------------|---|----------|--------|----------|-----------------|----------|\n`;

                // Table rows
                results.forEach(result => {
                    md += `| ${this.escapeMarkdown(result.section || 'N/A')} `;
                    md += `| ${result.question_number || ''} `;
                    md += `| ${this.escapeMarkdown(result.question || 'N/A')} `;
                    md += `| ${this.escapeMarkdown(result.answer || 'No answer found')} `;
                    md += `| ${this.escapeMarkdown(result.pdf_page || (result.chunk_number ? `Chunk ${result.chunk_number}` : 'N/A'))} `;
                    md += `| ${this.escapeMarkdown(result.citation || 'N/A')} `;
                    md += `| ${this.escapeMarkdown(result.footnote || '')} |\n`;
                });

                return md;
            }

            exportAsHTML(results) {
                // Professional HTML report with styling
                const projectName = this.currentFile?.name || 'Unknown Document';
                const date = new Date().toLocaleString();

                let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIPP Analysis Report - ${projectName}</title>
    <style>
        @media print {
            body { margin: 0.5in; }
            table { page-break-inside: auto; }
            tr { page-break-inside: avoid; page-break-after: auto; }
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #1E3A8A;
            border-bottom: 3px solid #5B7FCC;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .metadata {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 25px;
            border-left: 4px solid #2196F3;
        }

        .metadata p {
            margin: 5px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        thead {
            background: linear-gradient(135deg, #1E3A8A, #5B7FCC);
            color: white;
            font-weight: bold;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid #ddd;
            vertical-align: top;
        }

        th {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        tbody tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        tbody tr:hover {
            background-color: #e3f2fd;
            transition: background-color 0.2s;
        }

        .section-cell {
            font-weight: 600;
            color: #1E3A8A;
        }

        .number-cell {
            text-align: center;
            font-weight: 600;
            color: #5B7FCC;
        }

        .question-cell {
            font-weight: 500;
        }

        .answer-cell {
            max-width: 400px;
            word-wrap: break-word;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
            }

            table {
                font-size: 12px;
            }

            th, td {
                padding: 8px 10px;
            }

            .answer-cell {
                max-width: 200px;
            }
        }

        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
            text-align: center;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèóÔ∏è CIPP Bid-Spec Analysis Report</h1>

        <div class="metadata">
            <p><strong>Document:</strong> ${this.escapeHtml(projectName)}</p>
            <p><strong>Generated:</strong> ${date}</p>
            <p><strong>Total Results:</strong> ${results.length}</p>
            <p><strong>Sections Analyzed:</strong> ${[...new Set(results.map(r => r.section))].join(', ')}</p>
        </div>

        <table>
            <thead>
                <tr>
                    <th>Section Header</th>
                    <th>#</th>
                    <th>Question</th>
                    <th>Answer</th>
                    <th>PDF Page</th>
                    <th>Inline Citation</th>
                    <th>Footnote</th>
                </tr>
            </thead>
            <tbody>`;

                results.forEach(result => {
                    html += `
                <tr>
                    <td class="section-cell">${this.escapeHtml(result.section || 'N/A')}</td>
                    <td class="number-cell">${result.question_number || ''}</td>
                    <td class="question-cell">${this.escapeHtml(result.question || 'N/A')}</td>
                    <td class="answer-cell">${this.escapeHtml(result.answer || 'No answer found')}</td>
                    <td>${this.escapeHtml(result.pdf_page || (result.chunk_number ? `Chunk ${result.chunk_number}` : 'N/A'))}</td>
                    <td>${this.escapeHtml(result.citation || 'N/A')}</td>
                    <td>${this.escapeHtml(result.footnote || '')}</td>
                </tr>`;
                });

                html += `
            </tbody>
        </table>

        <div class="footer">
            <p>Generated by Municipal Pipe Tool - CIPP Bid-Spec Analyzer</p>
            <p>Report generated automatically - verify all information with original documents</p>
        </div>
    </div>
</body>
</html>`;

                return html;
            }

            exportAsJSON(results) {
                const exportData = {
                    metadata: {
                        generated: new Date().toISOString(),
                        document: this.currentFile?.name || 'Unknown',
                        total_results: results.length,
                        sections: [...new Set(results.map(r => r.section))],
                        version: '1.0.0'
                    },
                    results: results.map(result => ({
                        section_header: result.section || 'N/A',
                        question_number: result.question_number || null,
                        question: result.question || 'N/A',
                        answer: result.answer || 'No answer found',
                        pdf_page: result.pdf_page || (result.chunk_number ? `Chunk ${result.chunk_number}` : 'N/A'),
                        inline_citation: result.citation || 'N/A',
                        footnote: result.footnote || '',
                        confidence: result.confidence || 'medium',
                        chunk_number: result.chunk_number || null,
                        timestamp: result.analysis_timestamp || null
                    }))
                };

                return JSON.stringify(exportData, null, 2);
            }

            // Helper functions for escaping special characters
            escapeCsvField(field) {
                if (!field) return '';
                return String(field).replace(/"/g, '""');
            }

            escapeMarkdown(text) {
                if (!text) return '';
                return String(text).replace(/\|/g, '\\|').replace(/\n/g, ' ');
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            clearResults() {
                this.results = [];
                document.getElementById('resultsSection').style.display = 'none';
                document.getElementById('logContent').innerHTML = '';
                document.getElementById('logContainer').style.display = 'none';
                document.getElementById('exportBtn').disabled = true;
                ProgressTracker.hide();
                Logger.info("üóëÔ∏è Results cleared");
            }

            loadQuestionsFromStorage() {
                try {
                    const saved = localStorage.getItem('cipp_analyzer_questions');
                    if (saved) {
                        this.questionSections = JSON.parse(saved);
                        return true;
                    }
                } catch (error) {
                    Logger.warning('Could not load saved questions');
                }
                return false;
            }

            saveQuestionsToStorage() {
                try {
                    localStorage.setItem('cipp_analyzer_questions', JSON.stringify(this.questionSections));
                } catch (error) {
                    Logger.warning('Could not save questions to storage');
                }
            }

            exportQuestions() {
                const blob = new Blob([JSON.stringify(this.questionSections, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'cipp_analyzer_questions.json';
                a.click();
                URL.revokeObjectURL(url);
                Logger.success('Questions exported successfully');
            }

            addNewSection() {
                const sectionName = prompt('Enter section name:');
                if (sectionName && !this.questionSections[sectionName]) {
                    this.questionSections[sectionName] = {
                        enabled: true,
                        questions: ['New question...']
                    };
                    this.saveQuestionsToStorage();
                    this.updateQuestionSectionUI();
                    Logger.success(`Added new section: ${sectionName}`);
                } else if (this.questionSections[sectionName]) {
                    alert('Section already exists!');
                }
            }
        }

        // Global application instance
        let app = null;

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            app = new CIPPAnalyzer();
        });

        // Global functions for HTML event handlers
        async function testApiConnection() {
            const testBtn = document.getElementById('testConnectionBtn');
            const testStatus = document.getElementById('testStatusDisplay');

            if (!app.apiClient) {
                testStatus.textContent = '‚ùå API not configured';
                testStatus.style.backgroundColor = '#f8d7da';
                testStatus.style.color = '#721c24';
                testStatus.style.border = '1px solid #f5c6cb';
                testStatus.style.display = 'inline-block';
                Logger.error("API client not initialized");
                return;
            }

            // Disable button and show testing status
            testBtn.disabled = true;
            testStatus.textContent = 'üîÑ Testing connection...';
            testStatus.style.backgroundColor = '#fff3cd';
            testStatus.style.color = '#856404';
            testStatus.style.border = '1px solid #ffeaa7';
            testStatus.style.display = 'inline-block';

            try {
                const isConnected = await app.apiClient.testConnection();

                if (isConnected) {
                    testStatus.textContent = '‚úÖ Connection successful!';
                    testStatus.style.backgroundColor = '#d4edda';
                    testStatus.style.color = '#155724';
                    testStatus.style.border = '1px solid #c3e6cb';
                } else {
                    testStatus.textContent = '‚ùå Connection failed';
                    testStatus.style.backgroundColor = '#f8d7da';
                    testStatus.style.color = '#721c24';
                    testStatus.style.border = '1px solid #f5c6cb';
                }
            } catch (error) {
                testStatus.textContent = `‚ùå Error: ${error.message}`;
                testStatus.style.backgroundColor = '#f8d7da';
                testStatus.style.color = '#721c24';
                testStatus.style.border = '1px solid #f5c6cb';
            } finally {
                testBtn.disabled = false;
            }
        }

        function handleFileSelect(event) {
            app.handleFileSelect(event);
        }

        function startAnalysis() {
            app.startAnalysis();
        }

        function stopAnalysis() {
            app.stopAnalysis();
        }

        function clearResults() {
            app.clearResults();
        }

        function showExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }

        function exportResults(format) {
            app.exportResults(format);
        }

        // Close export menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('exportMenu');
            const exportBtn = document.getElementById('exportBtn');
            if (menu && exportBtn && !exportBtn.contains(event.target) && !menu.contains(event.target)) {
                menu.style.display = 'none';
            }
        });

        function showQuestionManager() {
            const modal = document.getElementById('questionManagerModal');
            const sectionSelect = document.getElementById('sectionSelect');

            // Populate section dropdown
            sectionSelect.innerHTML = '<option value="">-- Select a section --</option>';
            Object.keys(app.questionSections).forEach(sectionName => {
                const option = document.createElement('option');
                option.value = sectionName;
                option.textContent = sectionName;
                sectionSelect.appendChild(option);
            });

            modal.style.display = 'flex';
            Logger.info("üìù Question manager opened");
        }

        function hideQuestionManager() {
            document.getElementById('questionManagerModal').style.display = 'none';
            document.getElementById('sectionEditor').style.display = 'none';
        }

        function loadSectionForEdit() {
            const sectionName = document.getElementById('sectionSelect').value;
            if (!sectionName || !app.questionSections[sectionName]) {
                document.getElementById('sectionEditor').style.display = 'none';
                return;
            }

            const section = app.questionSections[sectionName];
            document.getElementById('currentSectionName').textContent = sectionName;
            document.getElementById('sectionNameInput').value = sectionName;
            document.getElementById('sectionEnabled').checked = section.enabled;

            // Load questions
            const questionsList = document.getElementById('questionsList');
            questionsList.innerHTML = '';

            section.questions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.style.cssText = 'margin-bottom: 10px; padding: 10px; background: white; border-radius: 4px; border: 1px solid #ddd;';
                questionDiv.innerHTML = `
                    <div style="display: flex; align-items: center; margin-bottom: 5px;">
                        <span style="font-weight: bold; margin-right: 10px;">${index + 1}.</span>
                        <button class="btn btn-danger" onclick="deleteQuestion(${index})" style="margin-left: auto; padding: 4px 8px; font-size: 12px;">üóëÔ∏è Delete</button>
                    </div>
                    <textarea onchange="updateQuestion(${index}, this.value)" style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; resize: vertical;">${question}</textarea>
                `;
                questionsList.appendChild(questionDiv);
            });

            document.getElementById('sectionEditor').style.display = 'block';
            Logger.info(`üìù Loaded section "${sectionName}" for editing (${section.questions.length} questions)`);
        }

        function toggleSectionEnabled() {
            const sectionName = document.getElementById('sectionSelect').value;
            if (sectionName && app.questionSections[sectionName]) {
                app.questionSections[sectionName].enabled = document.getElementById('sectionEnabled').checked;
                Logger.info(`Section "${sectionName}" ${app.questionSections[sectionName].enabled ? 'enabled' : 'disabled'}`);
            }
        }

        function updateSectionName() {
            const oldName = document.getElementById('sectionSelect').value;
            const newName = document.getElementById('sectionNameInput').value.trim();

            if (!oldName || !newName || oldName === newName) return;

            if (app.questionSections[newName]) {
                alert('A section with that name already exists!');
                document.getElementById('sectionNameInput').value = oldName;
                return;
            }

            // Rename section
            app.questionSections[newName] = app.questionSections[oldName];
            delete app.questionSections[oldName];

            // Update UI
            document.getElementById('currentSectionName').textContent = newName;
            const option = document.querySelector(`#sectionSelect option[value="${oldName}"]`);
            if (option) {
                option.value = newName;
                option.textContent = newName;
                document.getElementById('sectionSelect').value = newName;
            }

            Logger.info(`Section renamed from "${oldName}" to "${newName}"`);
        }

        function updateQuestion(index, newText) {
            const sectionName = document.getElementById('sectionSelect').value;
            if (sectionName && app.questionSections[sectionName]) {
                app.questionSections[sectionName].questions[index] = newText.trim();
                Logger.debug(`Updated question ${index + 1} in section "${sectionName}"`);
            }
        }

        function deleteQuestion(index) {
            const sectionName = document.getElementById('sectionSelect').value;
            if (sectionName && app.questionSections[sectionName]) {
                if (confirm('Are you sure you want to delete this question?')) {
                    app.questionSections[sectionName].questions.splice(index, 1);
                    loadSectionForEdit(); // Refresh the display
                    Logger.info(`Deleted question ${index + 1} from section "${sectionName}"`);
                }
            }
        }

        function addNewQuestion() {
            const sectionName = document.getElementById('sectionSelect').value;
            if (sectionName && app.questionSections[sectionName]) {
                app.questionSections[sectionName].questions.push('New question...');
                loadSectionForEdit(); // Refresh the display
                Logger.info(`Added new question to section "${sectionName}"`);
            }
        }

        function addNewSectionInManager() {
            const sectionName = prompt('Enter new section name:');
            if (sectionName && sectionName.trim()) {
                const trimmedName = sectionName.trim();
                if (app.questionSections[trimmedName]) {
                    alert('A section with that name already exists!');
                    return;
                }

                app.questionSections[trimmedName] = {
                    enabled: true,
                    questions: ['New question...']
                };

                // Update dropdown
                const option = document.createElement('option');
                option.value = trimmedName;
                option.textContent = trimmedName;
                document.getElementById('sectionSelect').appendChild(option);
                document.getElementById('sectionSelect').value = trimmedName;

                loadSectionForEdit();
                Logger.success(`Added new section: "${trimmedName}"`);
            }
        }

        function deleteCurrentSection() {
            const sectionName = document.getElementById('sectionSelect').value;
            if (!sectionName) {
                alert('Please select a section first.');
                return;
            }

            if (confirm(`Are you sure you want to delete the entire "${sectionName}" section and all its questions?`)) {
                delete app.questionSections[sectionName];

                // Remove from dropdown
                const option = document.querySelector(`#sectionSelect option[value="${sectionName}"]`);
                if (option) option.remove();

                document.getElementById('sectionSelect').value = '';
                document.getElementById('sectionEditor').style.display = 'none';

                Logger.warning(`Deleted section: "${sectionName}"`);
            }
        }

        function saveQuestions() {
            app.saveQuestionsToStorage();
            app.updateQuestionSectionUI();
            app.updateActiveQuestionCount();
            Logger.success('‚úÖ All questions saved successfully');
        }

        function importQuestions(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    if (confirm('This will replace all current questions. Are you sure?')) {
                        app.questionSections = imported;
                        app.saveQuestionsToStorage();
                        app.updateQuestionSectionUI();
                        app.updateActiveQuestionCount();
                        hideQuestionManager();
                        Logger.success('Questions imported successfully');
                    }
                } catch (error) {
                    alert('Invalid JSON file');
                    Logger.error('Failed to import questions: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function addQuestionSection() {
            app.addNewSection();
        }

        function exportQuestions() {
            app.exportQuestions();
        }

        function showSettings() {
            const modal = document.getElementById('settingsModal');
            document.getElementById('settingsApiKey').value = app.settingsManager.get('apiKey');
            document.getElementById('gptModel').value = app.settingsManager.get('gptModel');
            modal.style.display = 'flex';
        }

        function hideSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function saveSettings() {
            app.settingsManager.set('apiKey', document.getElementById('settingsApiKey').value);
            app.settingsManager.set('gptModel', document.getElementById('gptModel').value);
            document.getElementById('apiKey').value = app.settingsManager.get('apiKey');
            hideSettings();
            Logger.success('Settings saved successfully');
        }

        function loadTestDocument() {
            const testDocument = `CIPP REHABILITATION PROJECT SPECIFICATION

PROJECT INFORMATION:
Project Name: Main Street Sewer Rehabilitation Phase 2
Owner: City of Springfield Public Works Department
Engineer: ABC Engineering Consultants, Inc.
Contract Period: 120 calendar days from Notice to Proceed
Total Project Value: $1,850,000
Liquidated Damages: $500 per calendar day

PIPE SPECIFICATIONS:
The existing sewer system consists of 18-inch to 36-inch diameter reinforced concrete pipe (RCP) installed between 1965 and 1975. Total rehabilitation length is 8,500 linear feet. The pipes show moderate to severe deterioration with significant infiltration and some structural defects.

CIPP LINER REQUIREMENTS:
The contractor shall install cured-in-place pipe (CIPP) liners using vinyl ester resin with polyester felt tube. Minimum liner wall thickness shall be 6.5mm for 18-inch diameter pipes and 9.0mm for pipes 24-inch diameter and larger. The liner shall be cured using hot water curing method at minimum temperature of 180¬∞F for 4-6 hours depending on pipe diameter.

DEFLECTION AND TESTING:
Maximum allowable deflection after installation and curing shall not exceed 5% of the pipe diameter. Deflection testing shall be performed on a minimum of 10% of the total linear footage. All installations shall undergo pressure testing at 4 PSI for minimum 1 hour duration.

QUALITY CONTROL:
Pre-installation CCTV inspection is required for all pipe segments. Post-installation CCTV documentation shall be provided within 30 days of completion. All work shall be warranted for 5 years for materials and workmanship.

PAYMENT:
Work shall be measured and paid for by the linear foot of completed CIPP installation. Unit price for 18-inch diameter pipe is $135 per linear foot. Unit price for 24-inch and larger diameter pipe is $185 per linear foot.`;

            const blob = new Blob([testDocument], { type: 'text/plain' });
            const file = new File([blob], 'test_cipp_spec.txt', { type: 'text/plain' });

            const fileInput = document.getElementById('fileInput');
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            fileInput.files = dataTransfer.files;

            app.handleFileSelect({ target: { files: [file] } });
            Logger.success('üìÑ Test document loaded successfully');
        }
    </script>
</body>
</html>